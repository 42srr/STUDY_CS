# 챕터 2: 애플리케이션 계층 – 웹과 전자메일

이 챕터에서는 네트워크 애플리케이션이 어떻게 구성되고 동작하는지, 그리고 이들이 제공하는 다양한 서비스에 대해 다룹니다. 여기서는 애플리케이션의 기본 원리, 구조, 프로세스 간 통신, 그리고 전자메일 시스템의 핵심 구성 요소(전자메일 시스템의 상위 개념부터 SMTP까지)를 정리합니다.

</br>

## 2.1 네트워크 애플리케이션의 원리

네트워크 애플리케이션 개발의 중심은 **다른 위치에 있는 종단 시스템(호스트)에서 동작하는 프로그램**을 작성하여, 네트워크를 통해 서로 통신하게 하는 것이 목표이다.
> Ex) 웹 애플리케이션은 항상 켜져 있는 **서버**(웹 서버 프로그램)와 사용자 호스트에서 실행되는 **클라이언트**(웹 브라우저)로 구성

### 2.1.1 네트워크 애플리케이션 구조

**애플리케이션 구조 vs. 네트워크 구조**  
- **네트워크 구조**는 ISP, 라우터, 링크 등 고정된 인프라
- **애플리케이션 구조**는 개발자가 설계하며, 애플리케이션이 여러 종단 시스템에서 어떻게 조직되어 서비스를 제공할지를 정의

**클라이언트-서버 구조**  
  - **서버**: 항상 동작하며 고정 IP 주소를 가진 중앙 호스트
  - **클라이언트**: 서버에 서비스 요청을 보내며, 직접 통신하지 않고 서버를 통해 간접적으로 상호작용
  - **데이터 센터**: 대규모 서비스를 위해 수십만 개의 서버를 갖춘 가상 서버 풀을 구성

**P2P 구조**  
  - 중앙 서버에 의존하지 않고, 서로 간헐적으로 연결된 `피어(peer)`들이 직접 통신
  - 파일 공유와 같이 각 피어가 자원을 제공하고 분산 처리하는 자가 확장성(self-scalability)을 가짐

### 2.1.2 프로세스 간 통신

**프로세스와 소켓**  
- 실제 통신하는 단위는 실행 중인 프로그램, 즉 **프로세스**
- **소켓(Socket)**은 애플리케이션 계층과 트랜스포트 계층 사이의 인터페이스로, 프로세스가 네트워크를 통해 데이터를 보내고 받는 통로
- 프로세스는 **IP 주소**(호스트 식별)와 **포트 번호**(호스트 내의 특정 애플리케이션 식별)를 통해 서로 구분

### 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스

> 네트워크 애플리케이션은 트랜스포트 프로토콜(TCP, UDP 등)을 통해 아래와 같은 서비스를 제공한다.

**신뢰적 데이터 전송 (Data Integrity)**  
- TCP는 전송된 데이터가 오류 없이, 올바른 순서대로 도착하도록 보장
- 실시간 애플리케이션(예: VoIP, 비디오 스트리밍)에서는 데이터 손실을 감수하는 경우도 존재

**처리율 (Throughput)**  
- 애플리케이션은 대역폭 민감(높은 처리율 요구)하거나 탄력적(가용 처리율에 따라 동작)일 수 O
  
**시간 (Timing)**  
- 일부 애플리케이션은 낮은 지연시간(RTT)을 필요로 하며, 트랜스포트 프로토콜은 이를 위해 시간 보장을 제공
  
**보안 (Security)**  
- 데이터 암호화, 무결성 검증, 종단 인증 등 추가적인 보안 기능이 제공
- 예를 들어, HTTPS는 TCP 위에서 TLS를 사용하여 보안성을 강화

</br>

## 2.2 웹과 HTTP

웹은 현대 인터넷 애플리케이션의 대표적인 예로, 사용자가 원할 때 원하는 정보를 **온디맨드(on-demand)** 방식으로 제공하는 시스템이다. HTTP는 이러한 웹 애플리케이션을 구현하기 위한 핵심 애플리케이션 계층 프로토콜로, 클라이언트(웹 브라우저)와 서버 간의 메시지 교환 방식을 정의한다.

### 2.2.1 HTTP 개요

**HTTP의 역할**  
- 웹 애플리케이션 계층 프로토콜로, 웹 브라우저와 웹 서버가 서로 메시지를 주고받으며 웹 페이지와 그에 포함된 여러 객체(HTML, 이미지, 자바스크립트 등)를 전송
- HTTP는 텍스트 기반의 프로토콜로 사람이 읽을 수 있는 형식의 메시지(요청 및 응답)를 사용
- 클라이언트는 HTTP 요청 메시지를 통해 특정 URL의 자원을 요청하고, 서버는 HTTP 응답 메시지로 해당 자원을 전송

**TCP 기반의 신뢰성**  
- HTTP는 전송 계층에서 TCP를 사용하여 데이터의 신뢰성, 순서 보장, 오류 검출 및 복구 기능을 활용
- HTTP 애플리케이션은 TCP의 신뢰적인 전송 서비스에 의존하므로, 데이터 전송 중 발생하는 손실이나 순서 왜곡에 대해 신경 쓸 필요 X

**비상태(Stateless) 특성**  
- HTTP 서버는 각 요청을 독립적으로 처리하며, 이전의 요청 상태를 유지 X
- 이로 인해 서버는 단순하고 확장성이 높지만, 상태 유지를 위해 쿠키나 세션과 같은 별도의 메커니즘이 필요


### 2.2.2 비지속 연결과 지속 연결

#### 비지속 연결 (Non-persistent Connection)
- 각 HTTP 요청/응답 쌍마다 별도의 TCP 연결을 설정하고, 응답 후 연결을 종료
- **동작 과정**
  1. 클라이언트가 서버에 TCP 연결을 설정
  2. 클라이언트가 요청 메시지를 보내고, 서버가 응답 메시지를 전송
  3. 응답 후 TCP 연결이 종료
  4. 웹 페이지가 여러 객체로 구성된 경우, 각 객체마다 위의 과정을 반복 필요

#### 지속 연결 (Persistent Connection)
- 한 번 설정된 TCP 연결을 유지하면서, 같은 서버로 보내는 여러 HTTP 요청/응답을 하나의 연결에서 처리
- **특징**
  - **연결 유지**: 한 TCP 연결 내에서 다수의 HTTP 메시지를 주고받을 수 있으므로, 연결 설정 오버헤드가 감수수
  - **파이프라이닝(Pipelining)**: 클라이언트가 이전 요청의 응답을 기다리지 않고, 연속적으로 여러 요청 전송 가능능
  - **리소스 효율성**: 서버의 소켓 수와 관련 오버헤드가 줄어들어 대규모 접속에 유리


### 2.2.3 HTTP 메시지 포맷

HTTP 요청 메시지

![alt text](https://user-images.githubusercontent.com/76640167/210494014-891426d1-0c27-47dc-8271-c6f5bab316e9.png)

- **구성 요소**  
  1. **요청 라인**
     - Method (GET, POST, HEAD, PUT, DELETE 등)  
     - Request-URI (요청 자원의 경로)  
     - HTTP 버전 (예: HTTP/1.1)
  2. **헤더**
     - 예: `Host`, `Connection`, `User-Agent`, `Accept-Language` 등  
     - 각 헤더는 `키: 값` 형식으로 작성되고, CRLF로 구분
  3. **메시지 본문 (Body)**
     - 주로 POST 방식에서 사용되며, 폼 데이터 등이 포함

- **예시**

HTTP 응답 메시지

![alt text](https://user-images.githubusercontent.com/76640167/210497215-8265b94b-c82f-4ea8-9374-5f41fc6eaed1.png)

- **구성 요소**  
  1. **상태 라인 (Status Line)**
     - HTTP 버전, 상태 코드 (예: 200, 404 등), 상태 메시지 (예: OK, Not Found)
  2. **헤더**
     - 예: `Date`, `Server`, `Last-Modified`, `Content-Length`, `Content-Type` 등
  3. **메시지 본문 (Body)**
     - 요청한 자원의 데이터 (HTML, 이미지, 등)

### 2.2.4 사용자와 서버 간의 상호작용: 쿠키

-

### 2.2.5 웹 캐싱

`== aka. Proxy Server`

- **웹 캐싱 (Web Caching)**  
  - 프록시 서버나 CDN을 통해 자주 요청되는 웹 객체의 사본을 저장하여, 클라이언트 요청 시 원본 서버의 부하를 줄이고 응답 시간을 단축하기 위해 사용

- **조건부 GET (Conditional GET)** 
  - 클라이언트는 `If-Modified-Since` 헤더를 사용하여, 캐시된 객체가 최신 상태인지 확인
  - 서버는 객체가 수정되지 않았으면 304 Not Modified 응답을 보내어, 불필요한 데이터 전송을 줄임

</br>

## 2.3 인터넷 전자메일

전자메일는 인터넷의 시작된 이래로 널리 확산된 매우 있기는 애플리케이션으로, 오늘날 인터넷의 가장 중요하고 널리 사용되는 애플리케이션 중 하나이다.
일반 우편과  마찬가지로 전자메일은 비동기적인 통신 매체이다. -> 상대방의 수신여부와 상관없이 편할 때 메세지를 보내거나 읽는 것이 가능

</br>

![alt text](https://user-images.githubusercontent.com/76640167/210542924-1107ca75-eee8-45f6-829a-df0d0df81c15.png)

해당 그림은 인테넛 메일 시스템의 상위 레벨 개념을 보여주는 다이어그램으로 **사용자 에이전트**, **메일 서버**, **SMTP**라는 3개의 주요 요소가 있음을 알 수 있다.

> `User Agent`
> - 사용자가 메시지를 읽고, 응답하고, 전달하고, 저장하고, 구성하게 하는 역할
>
> `Mail Server`
> - 전자 메일 인프라스트럭처의 중심
> - mailbox: 메일 서버 안에 있으며, 수신자의 메시지를 유지하고 관리하는 역할
> - 전자메일 과정: 송신자의 user agent -> 송신자의 mail server -> 수신자의 mail server -> 수신자의 mailbox
>
> `SMTP`
> - 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜
> - 클라이언트와 서버 구조를 가짐 -> 클라이언트, 서버 모두가 모든 메일 서버에서 수행


### 2.3.1 SMTP (Simple Mail Transfer Protocol)

**주요 역할**
- RFC 5321에 정의된 인터넷 전자메일의 중심
- SMTP는 여러 가지 장장
- TCP의 신뢰적인 데이터 전송 서비스를 활용하며, 기본적으로 25번 포트를 사용

</br>

![alt text](https://user-images.githubusercontent.com/76640167/210545342-e280b01b-fff0-4ec7-b921-9bfcddb94999.png)

**동작 과정**(간략화)
  1. **송신자**의 사용자 에이전트(예: 이메일 클라이언트)는 메시지를 작성하여 자신의 메일 서버에 전달
  2. 송신자의 메일 서버는 메시지를 **메시지 큐**에 저장
  3. SMTP 클라이언트 역할을 하는 송신자의 메일 서버는 수신자의 메일 서버에 TCP 연결(25번 포트)을 설정
  4. 초기 SMTP 핸드셰이킹(HELO, MAIL FROM, RCPT TO, DATA, QUIT)을 통해 메시지를 전송하고, 수신자의 메일 서버는 이를 받아 **메일 박스**에 저장
  5. 수신자는 자신의 메일 서버에 저장된 메일을 사용자 에이전트를 통해 확인

	> SMTP는 직접 전송(direct transfer) 방식으로 동작하며, 중간 메일 서버를 거치지 X
	> 
	> 메시지 전송에 실패할 경우, 송신자의 메일 서버는 재시도를 수행하며, 일정 시간이 지나면 송신자에게 알림 전송

### 2.3.2 메일 메시지 포맷

전자메일을 보낼 때 주변 정보가 포함된 header가 body 앞에 위치

**구조**
- **헤더(Header)**
 - 필수 헤더: `From:`, `To:`  
 - 선택 헤더: `Subject:`, `Date:`, `CC:`, `BCC:` 등
- **본문(Body)**
 - 실제 메시지 내용이 포함
- 헤더와 본문은 빈 줄(CRLF)로 구분
  

### 2.3.3 메일 접속 프로토콜 (Mail Access Protocols)

- **메일 서버**는 사용자 메일 박스를 관리하며, SMTP를 통한 푸시(push) 방식으로 메일을 전달
- **메일 사용자 에이전트**(메일 클라이언트)는 저장된 메일을 읽어오기 위해 메일 서버에 접근
- **주요 프로토콜**
  - **IMAP (Internet Mail Access Protocol)**: 서버에 저장된 메일을 읽고 관리하는 데 사용
  - **POP3 (Post Office Protocol version 3)**: 메일을 서버에서 다운로드하여 로컬에서 관리하는 데 사용
- 웹 기반 메일 클라이언트는 HTTP 인터페이스를 통해 메일 서버와 통신
