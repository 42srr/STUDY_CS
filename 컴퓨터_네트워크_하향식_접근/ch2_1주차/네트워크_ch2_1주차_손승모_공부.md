# 2. 애플리케이션 계층

## 2.1 네트워크 애플리케이션의 원리

- 네트워크 애플리케이션 개발의 중심은 다른 위치의 종단 시스템에서 동작하고 네트워크를 통해 서로 통신하는 프로그램을 작성하는 것
- 웹 애플리 케이션의 종류 2가지
  - 사용자의 호스트에서 실행되는 브라우저 프로그램
  - 웹 서버 호스트에서 실행되는 웹 서버 프로그램

### 2.1.1 네트워크 애플리케이션 구조

- 애플리케이션 구조를 선택할 때 클라이언트-서버 구조 혹은 P2P 구조 중 하나로 작성될 것
- 클라이언트 서버 구조
  - 서버 : 항상 동작하고 있는 호스트
  - 클라이언트 : 다른 호스트들로부터 서비스 요청을 받는 곳
  - 클라이언트 호스트는 가끔 또는 항상 켜져 있을 수 있다.
  - 클라이언트-서버 구조에서 클라이언트는 서로 직접적으로 통신하지 않는다.
  - 클라인언트-서버 애플리케이션에서 하나의 서버 호스트가 자신의 클라이언트로부터 오는 모든 요청에 다 응답하는 것은 불가능하다.
- P2P 구조
  - 항상 켜져 있는 인프라스트럭쳐 서버에 최소로 의존한다 (혹은 의존하지 않는다.)
  - 피어라는 간헐적으로 연결된 호스트쌍이 서로 직접 통신
  - 자가확장성
  - 고도의 분산 구조 특성으로 인해 보안, 성능, 신뢰성에서 도전을 맞는 중

### 2.1.2 프로세스 간 통신

- 운영체제 용어에서 실제 통신하는 것은 프로그램이 아닌 프로세스
- 프로세스는 종단 시스템에서 실행되는 프로그램이다.
- 2개의 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 메시지 교환으로 서로 통신한다.

#### 클라이언트와 서버 프로세스

- 통신하는 프로세스 각 쌍에 대해 일반적으로 클라이언트의 프로세스와 서버의 프로세스 중 하나로 이름 짓는다.
  - 클라이언트 프로세스 : 두 프로세스 간의 통신 세션에서 통신을 초기화 (다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스
  - 서버 : 세션을 시작하기 위해 접속을 기다리는 프로세스

#### 프로세스와 컴퓨터 네트워크 사이의 인터페이스

- 프로세스는 소켓을 통해 네트워크로 메시지를 보내고 받는다.
- 소켓
  - 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스
  - 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스
  - API라고도 불림.
  - 애플리케이션 개발자는 소켓의 트랜스포트 계층에 대한 통제권은 거의 갖지 못한다.

#### 프로세스 주소 배정

- 수신 프로세스를 식별하기 위해 명시되어야 하는 정보
  1. 호스트의 주소
  2. 그 목적지 호스트 내의 수신 프로세스를 명시하는 식별자
- 호스트는 IP 주소로 식별
- IP주소가 32비트로 구성되며 호스트를 유일하게 식별함.
- 목적지 포트 번호 : 수신 호스트에서 수행되고있는 수신 프로세스 (소켓)의 식별자

### 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스

- 소켓 : 애플리케이션 프로세스와 트랜스포트 프로토콜 간의 인터페이스
- 트랜스 포트 계층 프로토콜의 서비스
  - 신뢰적 데이터 전송
  - 처리율
  - 시간
  - 보안

#### 신뢰적 데이터전송

- 신뢰적 데이터 전송 : 프로토콜이 보장된 데이터 전송 서비스를 제공
- 신뢰적 데이터 전송을 제공하지 않을 경우 송신 프로세스가 보낸 데이터는 수신 프로세스에 전혀 도착하지 않을 수 있다.
- 손실 허용 애플리케이션 : 어느 정도의 데이터 손실을 참아낼 수 있음. ex) 실시간 오디오/비디오

#### 처리율

- 처리율 : 네트워크 경로를따라 두 프로세스 간의 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율을 나타냄
- 대역폭 민감 애플리케이션 : 처리율 요구사항을 갖는 애플리케이션
- 탄력적 애플리케이션 : 가용한 처리율이 많으면 많은 대로 적으면 적은 대로 이용 가능

#### 시간

- 시간 보장의 예
  - 송신자가 소켓을 내보내는 모든 비트가 수신자의 소켓에 100ms 내에 도착하게 하는 것
    - 실시간 상호작용 애플리케이션에 매력적
    - 데이터 전송에 엄격한 시간 제한 조건이 요구

#### 보안

- 기밀성,
- 데이터 무결성,
- 종단 인증

### 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스

- 인터넷(그리고 일반적인 TCP/IP 네트워크)은 애플리케이션에게 2개의 전송 프로토콜을 제공
  - UDP (User Datagram Protocol)
  - TCP (Transmission Control Protocol)

#### TCP 서비스

- 연결지향형 서비스와 신뢰적인 데이터 전송 서비스를 포함
- 연결 지향형 서비스
  - 애플리케이션 계층 메시지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환함
  - 핸드셰이킹 과정이 클라이언트와 서버에 패킷이 곧 도달할테니 준비하라고 알려주는 역할
  - 서로 동시에 메시지를 보낼 수 있기에 전이중 연결이라고 부름
- 신뢰적인 데이터 전송 서비스
  - TCP는 애플리케이션의 한쪽이 바이트 스트림을 소켓으로 전달하면 그 바이트 스트림이 손실되거나 중복되지 않게 수신 소켓으로 전달한다.
- 혼잡 제어 방식
  - 통신하는 프로세스의 직접 이득보다는 인터넷의 전체 성능 향상을 위한 서비스를 포함한다.
  - 네트워크가 혼잡 상태에 이르면 프로세스 속도를 낮춘다.

#### UDP 서비스

- 비연결형이므도 두 프로세스가 통신을 하기 전에 핸드셰이킹을 하지 않는다.
- 비신뢰적인 데이터 전송 서비스를 제공한다.
- 혼잡 제어 방식을 포함하지 않는다 따라서 UDP의 송신 측은 데이터를 원하는 속도로 하위계층으로 보낼 수 있다.

### 2.1.5 애플리케이션 계층 프로토콜

- 애플리케이션 계층 프로토콜 : 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 정의함
  - 교환 메시지 타입
  - 여러 메시지 타입의 문법
  - 필드의 의미, 즉 필드에 있는 정보의 의미
  - 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙
- 네트워크 애플리케이션과 애플리케이션 계층 프로토콜을 구분하는 것은 중요
- 애플리케이션 계층 프로토콜은 네트워크 애플리케이션의 한 요소일뿐이다.

### 2.1.6 이책에서 다루는 네트워크 애플리케이션

## 2.2 웹과 HTTP

### 2.2.1 HTTP 개요

- HTTP (HyperText Transfer Protocol)는 웹의 애플리케이션 계층 프로토콜로 웹의 중심이다.
- 클라이언트 프로그램과 서버 프로그램으로 구현된다.
- 각기 다른 종단 시스템에서 수행되는 클라이언트, 서버 프로그램은 서로 HTTP 메시지를 교환하여 통신한다.
- 웹페이지는 객체들로 구성된다
- 객체는 단순히 단일 URL로 지정할 수 있는 하나의 파일이다.
- 대부분의 웹 페이지는 기본 HTMLK 파일과 여러 참조 객체로 구성된다.
- 웹 브라우저는 HTTP의 클라이언트 측에서 구현하기 때문에 웹의 관점에서 브라우저와 클라이언트라는 용어를 혼용하여 사용할 것이다.
- 브라우저는 요구한 웹 페이지를 보여주고 여러 가지 인터넷 항해와 구성 특성을 제공한다
- HTTP의 서버 측 구현하는 웹 서버는 URL로 각각을 지정할 수 있는 웹 객체를 갖고 있다.
- HTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의한다.
- HTTP는 TCP를 전송 프로토콜로 사용한다.
- HTTP 서버는 클라이언트에 대한 정보를 유지하지않으므로, HTTP를 비상태 프로토콜이라고 한다.

### 2.2.2 비지속 연결과 지속 연결

- 비지속 연결 : 각 요구 / 응답 쌍이 분리된 TCP 연결을 통해 보내져야 하는가?
- 지속 연결 : 모든 요구와 해당하는 응답들이 같은 TCP 연결상으로 보내져야 하는가?

#### 비지속 연결 HTTP

- 연결이 다른 객체를 위해 유지되지 않는다.
- HTTP/1.0은 비지속 연결을 지원한다.
- RTT (round-trip-time)
  - 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는데 걸리는 시간.
  - 패킷 전파 지연, 중간 라우터와 스위치에서의 패킷 큐잉 지연, 패킷 처리 지연 등을 포함함
- 비지속 연결의 단점
  - 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다.
    - TCP 버퍼가 할당되어야 하고 TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 한다.
  - 각 객체는 2RTT를 필요로 한다.

#### 지속 연결

- 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지한다.
- 같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내진다.
- 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수 있다.

### 2.2.3 HTTP 메시지 포맷

- 요청 메시지
- 응답 메시지

#### HTTP 요청 메시지

- 요청 라인
  - 요청 메시지의 첫 줄
  - 방식 (method) 필드, URL 필드, HTTP 버전 필드를 갖는다.
- 헤더 라인
  - 요청 라인 이후의 줄들
  - 웹 프록시 캐시에서 필요로 함.
- 개체 몸체 (entity body)
  - Get 방식에서는 비어있고 POST 방식에서 사용된다.
  - 사용자의 폼 필드에 입력한 것을 포함한다.

### 2.2.4 사용자와 서버 간의 상호작용 : 쿠키

- HTTP 서버는 상태를 유지 않는다.
- 쿠키는 사이트가 사용자를 추적하게 해준다.
- 쿠키 기술의 네 가지 요소
  - HTTP 응답 메시지 쿠키 헤더 라인
  - HTTP 요청 메시지 쿠키 헤더 라인
  - 사용자의 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일
  - 웹사이트의 백엔드 데이터 베이스
- 쿠키는 사용자 식별에 사용함
- 쿠키는 서버가 사용자의 정보를 저장하는 수단이다.
- 쿠키 동작 과정 :
  - 서버가 사용자에 대한 id 생성 (Set-cookie: 헤더)
  - 백엔드 데이터베이스 엔트리
  - 쿠키에 해당하는 동작

### 2.2.5 웹 캐싱

- 웹 캐시 (프록시 서버) : 기점 웹 서버를 대신하여 HTTP 요구를 충족시키는 네트워크 개체
- 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존한다.
- 캐시는 서버이면서 클라이언트이다.
- 장점
  - 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다.
  - 한 기관에서 인터넷으로의 접속하는 링크상의 웹 트래픽을 대폭 줄일 수 있다.

#### 조건부 GET

- 웹 캐싱이 캐시 내부에 있는 객체의 복사본이 새것이 아닐 수 있다는 점이 문제가 될 수 있다.
- 즉 복사본이 클라이언트에 캐싱된 이후에 웹 서버에 있는 객체가 갱신되었을 수도 있다.
- 조건부 GET
  - HTTP는 클라이언트가 브라우저로전달되는 모든 객체가 최신의 것임을 확인하면서 캐싱을 하게 해주는 방식
  - If-Modified-Since 헤더 라인을 포함한다면 조건부 GET 메시지

### 2.2.6 HTTP/2

- 주요목표
  - 하나의 TCP 연결상에서 멀티플렉싱 요청 / 응답 지연 시간을 줄이는데 있다. (HOL 블로킹 문제 해결)
  - 요청 우선순위화, 서버 푸시 HTTP 헤더 필드의 효율적인 압축 기능 등을 제공한다.
  - 웹 페이지를 전송하기 위한 병렬 TCP 연결의 수를 줄이거나 제거하는 데 있다.
    - 이는 서버에서 열고 유지하는 데 필요한 소켓의 수를 줄인다
    - 또한 목표한 대로 TCP 혼잡 제어를 제어할 수 있게 된다.

#### HTTP/2 프레이밍

- HTTP/2는 각 메시지를 작은 프레임으로 나누고, 같은 TCP 연결에서의 요청과 응답 메시지를 인터리빙 한다.
- HTTP 메시지를 독립된 프레임들로 쪼개고 인터리빙하고 반대편 사이트에서 재조립 하는 것.
- 프레이밍은 HTTP/2 프로토콜의 프레임으로 구현된 다른 프레이밍 서브 계층에 의해 이루어진다.
- 프레이밍 서브 계층은 프레임을 바이너리 인코딩한다.

#### 메시지 우선순위화 및 서버 푸싱

- 메시지 우선순위화
  - 개발자들로 하여금 요청들의 상대적 우선 순위를 조정할 수 있게 함으로써 애플리케이션의 성능을 최적화
  - 프레이밍 서브 계층 같은 요청자로 향하는 메시지를 병렬적인 데이터 스트림으로 쪼개어 준다.
  - 각 메시지에 가중치를 부여함으로써 요청에 우선순위를 매길 수 있다.
- 서버 푸싱
  - 서버로 하여금 특정 클라이언트 요청에 대해 여러 개의 응답을 보낼 수 있게 해준다.
  - 서버는 클라이언트의 요청 없이도 추가적인 객체를 클라이언트에게 푸시하여 보낼 수 있다.
  - 객체에 대한 HTTP 요청을 기다리는 대신 서버는 HTML 페이지를 분석할 수 있다
  - 또한 이를 통해 필요한 객체들을 식별 할 수 있고 해당 객체들에 대한 요청이 도착하기도 전에 해당 객체들을 클라이언트로 보낸다

#### HTTP/3

- HTTP/3은 QUIC 위에서 작동하도록 설계된 새로운 HTTP 프로토콜
- 완전히 표준화된 상태는 아님
- QUIC
  - UDP 프로토콜 위에 위치하는 애플리케이션 계층에 구현
  - 메시지 멀티 플렉싱, 스트림별 흐름 제어, 저지연 연결 확립의 특징을 가짐.

## 2.3 인터넷 전자메일

- 인터넷 메일 시스템의 상위 레벨 개념
  - 사용자 에이전트 : 사용자가 메시지를 읽고, 응답하고, 전달하고, 저장하고, 구성하게 해줌
  - 메일 서버 : 전자메일 인프라스트럭처의 중심
  - SMTP (Simple Mail Transfer Protocol) : 인터넷 전자 메일을 위한 애플리케이션 계층 프로토콜

### 2.3.1 SMTP

- 송신자의 메일 서버로부터 수신자의 메일 서버로 메시지를 전송함.
- 단순히 7비트 ASCII 제한을 함.

### 2.3.2 메일 메시지 포맷

- 전자 메일을 보낼 때도 주변 정보가 포함된 헤더가 메시지 몸체 앞에 오게 된다.

### 2.3.3 메일 접속 프로토콜

- 메일 서버가 메일박스를 관리하고 SMTP의 클라이언트와 서버 측 모두를 수행함.
- SMTP는 푸시 프로토콜인 반면 메시지를 얻는 것은 풀 동작이다.
- IMAP(Internet Mail Access Protocol) : 인터넷 메일 접근 프로토콜이며 이것이 풀 하는 동작을 수행함
