## 2.1 네트워크 애플리케이션의 원리

**네트워크 애플리케이션**: 다른 위치의 종단 시스템에서 동작하고 네트워크를 통해 서로 통신하는 프로그램

### 2.1.1 네트워크 애플리케이션 구조

- **클라이언트-서버 구조** (client-server architecture)

    : 클라이언트 호스트로부터 객체를 요청받으면 서버는 요청된 객체를 클라이언트 호스트로 보내면서 응답

    - **서버(server)**: 항상 동작하고 있고 서비스를 제공하는 호스트
        - 고정 IP 주소
    - **클라이언트(client)**: 서비스를 요청하는 다른 호스트
        - 서로 직접적으로 통신하지 않음
    
    **특징**
    
    - 하나의 서버가 모든 요청에 다 응답하는 것은 불가능하여 강력한 가상의 서버인 **데이터 센터**를 활용

- **P2P(Peer to Peer) 구조**

    : 항상 켜져있는 인프라스트럭처 서버에 최소로 의존하고 애플리케이션은 피어(peer)라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신

    - **peer**: 서비스 제공자가 소유하지 않고 사용자들이 제어하는 데스크톱, 랩톱
    
    **특징**
    
    - 자가 확장성(self-scalability): 파일 요구와 동시에 파일 분배
    - 비용 효율적: 서버 대역폭 요구 없음

### 2.1.2 프로세스 간 통신

**프로세스**: 종단 시스템에서 실행되는 프로그램

**다른 호스트에서 실행되는 프로세스와의 통신**

- **메시지 교환**
    - **송신 프로세스**: 메시지를 만들어 네트워크로 보냄
    - **수신 프로세스**: 메시지를 받고 역으로 메시지를 보냄으로써 응답
    
    #### 클라이언트와 서버 프로세스
    
    - **클라이언트**: 두 프로세스 간의 통신 세션에서 통신을 초기화하는 프로세스
    - **서버**: 세션을 시작하기 위해 접속을 기다리는 프로세스
    
    #### 프로세스와 컴퓨터 네트워크 사이의 인터페이스
    - **소켓(socket)**: 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스
        - 프로세스는 소켓을 통해 네트워크로 메시지를 주고 받음
        - 프로세스는 집, 소켓은 출입구로 비유할 수 있음
        - 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스이므로 애플리케이션과 네트워크 사이의 API(application programming interface)라고도 함
        - 애플리케이션 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 가지지만 트랜스포트 계층에 대한 통제권은 갖지 않음
        
        **트랜스포트 계층에 대한 애플리케이션 개발자의 통제**
        
        1. 트랜스포트 프로토콜 선택
        2. 약간의 트랜스포트 계층 매개변수 설정(최대 버퍼와 최대 세그먼트 크기 등)
    
    #### 프로세스 주소 배정
    
    **IP 주소**: 32비트로 구성되어 호스트를 유일하게 식별
    
    - 송신 호스트는 수신 호스트의 IP 주소와 수신 소켓을 식별해야 함
    - 이를 위해 **포트번호** 사용

### 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스

#### 트랜스포트 계층 프로토콜이 애플리케이션들에게 제공할 수 있는 서비스

- **신뢰적 데이터 전송**
    - 패킷손실에 대비한 보장된 데이터 전송 서비스 제공
- **처리율**
    - 네트워크 경로를 따라 두 프로세스 간의 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율
    - 애플리케이션은 r 비트/초의 보장된 처리율 요구, 트랜스포트 프로토콜은 가용한 처리율이 최소 r bps임을 보장
    - 트랜스포트 프로토콜이 이 처리율을 제공할 수 없다면 애플리케이션은 낮은 속도로 처리하거나 포기해야 함
    - **대역폭 민감 애플리케이션(bandwidth-sensitive application)**: 처리율 요구사항을 갖는 애플리케이션
        - cf) 탄력적 애플리케이션(elastic application)
- **시간**
    - 시간 제한 조건
- **보안**
    - 암호화, 암호해독 → 기밀성, 데이터 무결성, 종단 인증 등

### 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스

인터넷이 제공하는 애플리케이션 지원 유형

#### TCP 서비스

- 연결지향형 서비스: 핸드셰이킹 → 전이중 연결
- 신뢰적인 데이터 전송 서비스: 모든 데이터를 오류 없이 올바른 순서로 전달
- 혼잡 제어 방식: 혼잡 상태에 이르면 프로세스 속도 낮춤

#### UDP 서비스

- 비연결형: 핸드셰이킹 없음
- 비신뢰적인 데이터 전송 서비스
- 혼잡 제어 없음: 송신 측은 데이터를 원하는 속도로 하위 계층에 보낼 수 있음

### 2.1.5 애플리케이션 계층 프로토콜

다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법 정의

- 교환 메시지 타입(요청 메시지와 응답 메시지)
- 여러 메시지 타입의 문법(메시지 내부의 필드와 필드 간의 구별 방법 등)
- 필드의 의미, 필드에 있는 정보의 의미
- 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙

- `www.someSchool.edu`: 호스트 이름
- `someDepartment/picture.gif`: 경로 이름

- 웹 브라우저: HTTP의 클라이언트 측을 구현. 요구한 웹 페이지를 보여주고 여러 가지 인터넷 항해와 구성 특성 제공
- 웹 서버: URL로 각각 지정할 수 있는 웹 객체를 가지고 있음

→ 사용자가 웹 페이지를 요청할 때 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메시지를 서버에 보냄.  
서버는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답.

### 2.2.2 비지속 연결과 지속 연결

#### 비지속 연결

: 각 요구/응답 쌍이 분리된 TCP 연결을 통해 보냄

- 서버가 객체를 보낸 후 TCP 연결을 끊는다면 비지속 연결임
- 각 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만 전송

#### RTT (Round-trip time)

: 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 돌아오는데 걸리는 시간

- 패킷 전파 지연, 중간 라우터와 스위치에서의 패킷 큐잉 지연 등을 포함
- 세 방향 핸드셰이킹에서 처음 두 부분이 경과하면 한 RTT가 계산됨

#### 지속 연결

: 모든 요구와 해당하는 응답들이 같은 TCP 연결 상으로 보내짐

- 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지

단점

- 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 함
    - TCP 버퍼가 할당되어야 하고 TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 함
    → 수많은 클라이언트들의 요청을 동시에 서비스하는 웹 서버에 부담을 줄 수 있음
- 각 객체는 2 RTT를 필요로 함

### 2.2.3 HTTP 메시지 포맷

#### HTTP 요청 메시지

예시
```
GET / somedir/page.html HTTP /1.1 // 요청 라인
Host: www. someschool. edu // 이후 줄들은 헤더 라인
Connection: close // 지속 연결을 원하지 않음
User-agent: Mozilla/ 5.0 // 서버에게 요청하는 브라우저 타입 명시
Accept-language: fr // 프랑스어 버전
```

- 일반 ASCII 텍스트의 메시지
- 다섯 줄로 되어 있고 각 줄은 CR(carriage return)과 LF(line feed)로 구분
    - 요청 메시지는 더 많은 줄로 구성되거나 하나의 줄이 될 수 있음
- 요청 라인은 3개의 필드(방식 필드, URL 필드, HTTP 버전 필드)를 가짐

HTTP 요청 메시지의 일반 포맷:

```
방식 sp URL sp 버전 cr lf
헤더 필드 이름: sp 값 cr lf
…
헤더 필드 이름: sp 값 cr lf
cr lf
개체 몸체: // get 방식에는 비어있고 post 방식에서 사용됨
```


- `GET`: 브라우저가 URL 필드로 식별되는 객체를 요청할 때 사용
- `POST`: 주로 폼 형태에 사용
- `HEAD`: 흔히 디버깅을 위해 많이 사용
- `PUT`: 웹 서버에 업로드할 객체를 필요로 하는 애플리케이션에 의해 사용
- `DELETE`: 사용자 또는 애플리케이션이 웹 서버에 있는 개체를 지우기 허용

#### HTTP 응답 메시지

HTTP 응답 메시지의 일반 포맷:

```
// 상태라인: 요청 객체 포함
버전 sp 상태코드 sp 문장 cr lf
// 헤더라인
헤더 필드 이름: sp 값 cr lf
...
헤더 필드 이름: sp 값 cr lf
// 공백 라인
cr lf
// 개체 몸체
```


상태코드

- `200 OK`: 요청 성공, 정보가 응답으로 보내짐
- `301 Moved Permanently`: 요청 객체가 영원히 이동됨. 새로운 응답 메시지의 `Location` 헤더에 나와 있고, 클라이언트 소프트웨어는 자동으로 새로운 URL을 추출
- `400 Bad Request`: 서버가 요청을 이해할 수 없음
- `404 Not Found`: 요청 문서가 서버에 존재하지 않음
- `505 HTTP Version Not Supported`: 요청 프로토콜 버전을 서버가 지원하지 않음

### 2.2.4 사용자와 서버 간의 상호작용: 쿠키

쿠키: 사용자 추적

쿠키 기술의 네 가지 요소

1. HTTP 응답 메시지 쿠키 헤더 라인
2. HTTP 요청 메시지 쿠키 헤더 라인
3. 사용자의 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일
4. 웹사이트의 백엔드 데이터베이스

쿠키 동작 원리

- 특정 웹서버에 요청이 들어올 때 그 서버는 유일한 식별번호를 만들고 이 식별번호로 인덱싱되는 백엔드 데이터베이스 안에 엔트리를 만듦
- 그 후 웹 서버는 특정 클라이언트의 브라우저에 응답하는데 이 HTTP 응답에 식별번호를 담고 있는 `Set-Cookie:` 헤더가 포함

→ 활동 추적 가능. 사용자 식별에 활용 가능

### 2.2.5 웹 캐싱

웹 캐시: 기점 웹 서버를 대신하여 HTTP 요구를 충족시키는 네트워크 개체

- 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존

1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보냄
2. 웹 캐시는 객체의 사본이 자신에게 있는지 확인. 있다면 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체 전송
3. 없다면 기점 서버에 TCP 연결을 설정. 캐시와 서버 간의 TCP 연결로 객체에 대한 HTTP 요청을 보냄. 요청 받은 후, 서버는 웹 캐시로 HTTP 응답 메시지와 함께 객체 전송
4. 웹 캐시의 객체를 수신할 때 객체의 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 전송

- 캐시는 서버이면서 클라이언트
- ISP가 구입하고 설치

장점

1. 응답 시간 감소
2. 한 기관에서 인터넷으로 접속하는 링크 상의 웹 트래픽을 대폭 감소

#### 조건부 GET

클라이언트가 브라우저로 전달되는 모든 객체가 최신의 것임을 확인하면서 캐싱을 하게 해주는 방식

- HTTP가 조건부 GET 방식을 사용하고, `If-Modified-Since:` 헤더 라인 포함

### 2.2.6 HTTP/2

- TCP 연결 상에서 멀티플렉싱 요청/응답 지연 시간을 줄임
- 요청 우선순위화, 서버 푸시, HTTP 헤더 필드의 효율적인 압축 기능 제공
- 클라이언트와 서버 간 데이터 포맷 방법과 전송 방법 변경

#### HTTP/2 플레이밍

- 블로킹 문제를 해결하기 위해 각 메시지를 작은 프레임으로 나누고, 같은 TCP 연결에서의 요청과 응답 메시지 인터리빙

#### 메시지 우선순위화 및 서버 푸시

- 상대적 우선 순위 조정, 애플리케이션 성능 최적화
- 특정 클라이언트 요청에 대해 여러 개의 응답을 보낼 수 있게 함

## 2.3 인터넷 전자메일

### 2.3.1 SMTP

- 송신자의 메일 서버로부터 수신자의 메일 서버로 메시지 전송
- 두 메일 서버가 먼 거리에 있더라도 중간 메일 서버를 사용하지 않음

송신 메일에서 수신 메일 서버로 전송하는 법

1. 클라이언트 SMTP는 서버 SMTP의 25번 포트로 TCP 연결 설정
2. 핸드셰이킹 수행
    - SMTP 클라이언트는 송신자의 전자메일 주소와 수신자의 전자메일 주소 제공
3. 클라이언트의 메시지 전송
4. 모두 전송 후 TCP에게 닫을 것 명령

### 2.3.2 메일 메시지 포맷

- 헤더: 주변 정보 포함
- 메시지 몸체

### 2.3.3 메일 접속 프로토콜

- 메일 서버가 메일박스를 관리하고 SMTP의 클라이언트와 서버 측 모두 수행
