# 네트워크 계층: 제어 평면

## 5.1 개요

##### 포워딩 테이블이나 플로우 테이블이 어떻게 만들어지고 유지 및 설치될까? : 크게 2가지 방법

- (1) 라우터별 제어 
    - 라우팅 알고리즘들이 모든 라우터 각각에서 동작
    - 포워딩과 라우팅 기능이 모두 개별 라우터에 포함됨 
    - 다른 라우터의 라우팅 구성요소와 통신하여 자신의 포워딩 테이블의 값을 계산하는 라우팅 구성요소를 가지고 있음
    - OSBF, BGP 프로토콜이 이 라우터 제어방식을 기반으로 함 
![image.png](attachment:ca556a2d-c44b-40b9-ae2b-8c8f1b239686:image.png) 
- (2) 논리적 중앙 집중형 제어
    - 논리적 중앙 집중형 컨트롤러가 포워딩 테이블을 작성하고 이를 모든 개별 라우터가 사용할 수 있도록 배포한 경우
    - 매치 플러스 액션 (match plus action)
        => 부하 분산, 방화벽, NAT, 전통적인 IP 포워딩 과 같은 다양한 기능을 수행 가능
        (원래는 별도의 장치로 구현되었던 기능)
    - 라우터의 제어 에이전트(CA, control agent)와 상호작용하여 라우터의 플로우 테이블을 구성 및 관리
        - CA는 서로 직접 상호작용하지 않고, 최소한의 기능만 가짐
![image.png](attachment:b0797361-ea7b-42b4-8eb7-826a0ba7b556:image.png)
## 5.2 라우팅 알고리즘 (routing algorithm)

- 라우팅 알고리즘의 목표 : 송신자부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로(= 최소 비용 경로)를 결정하는 것
- 라우팅 문제는 보통 그래프를 사용하여 표현
    - 그래프 : G (N, E), 노드(N)와 엣지(E)의 집합 
    - 노드는 패킷 전달 결정이 이루어지는 지점인 라우터, 에지는 라우터들 간의 물리 링크를 나타냄
    - 에지는 비용을 나타내는 값을 가짐
        - 비용에는 일반적으로 해당 링크의 물리적인 거리, 링크 속도, 링크와 관련된 금전 비용 등이 반영됨
    - 집합 E에 포함된 어떤 에지(x,y)에 대해 c(x,y)는 노드 x, y 간의 비용을 의미 
    - 만약 노드 쌍 (x,y)가 E에 포함되어 있지 않으면 c(x,y)=infinity 로 둠 
    - 에지 (x, y)가 집합 E에 속하면 노드 y는 노드 x의 이웃이라고 함 
    - G (N, E)에서의 경로(path)는 노드의 연속이고 노드 쌍은 집합 E에 속한 에지들임 
    - 경로 (X1, X2, X3, ..., Xp)는 경로상 모든 에지 비용의 단순 합, 즉 c(x1, x2) + c(x2, x3) + ... + c(xp-1, xp)임  
    - 최소 비용 경로는 하나일 수도 있고 여러 개일 수도 있음 

##### 라우팅 알고리즘을 분류하는 일반적인 방법 : 중앙 집중형 vs 분산형

- (1) 중앙 집중형 라우팅 알고리즘 (centralized routing algorithm)
    - 네트워크 전체에 대한 완전한 정보를 가지고 출발지와 목적지 사이의 최소 비용 경로를 계산 
    - 계산 자체는 한 장소에서 수행되거나 모든 라우터 각각의 라우팅 모듈로 복사될 수 있음 
    - 핵심 : 연결과 링크 비용에 대한 완전한 정보를 갖는다
    - 링크 상태(link state, LS)알고리즘 : 링크 비용을 알고 있어야 함
- (2) 분산 라우팅 알고리즘 (decentralized routing algorithm)
    - 라우터들에 의해 반복적이고 분산된 방식으로 수행됨 
    - 어떤 노드도 모든 링크의 비용에 대한 완전한 정보를 갖고 있지는 않음
    - 각 노드는 자신에게 직접 연결된 링크에 대한 비용 정보만을 가지고 있음  
    - 정보 교환을 통해 노드는 점차적으로 목적지 또는 목적지 집합까지의 최소 비용 경로를 계산 
    - ex. 거리 벡터 알고리즘 (distance vector, DV)
        - 각 노드가 네트워크 내 다른 모든 노드까지 비용의 추정값을 벡터 형태로 유지하기 때문

##### 라우팅 알고리즘을 분류하는 또 다른 방법 : 정적 라우팅 알고리즘 vs 동적 라우팅 알고리즘

- (1) 정적 라우팅 알고리즘 (static routing algorithm)
    - 종종 사람이 개입한 결과로 경로는 아주 느리게 변함
- (2) 동적 라우팅 알고리즘 (dynamic routing algorithm)
    - 네트워크 트래픽 부하 (load)나 토폴로지 변화에 따라 라우팅 경로를 바꿈 
    - 경로 루프(loop)나 경로 진동(oscillation) 같은 문제에 취약

##### 라우팅 알고리즘을 분류하는 또, 다른 방법 : 부하에 민감한가?

- (1) 부하에 민감한 알고리즘 (load-sensitive algorithm)
    - 링크 비용은 혼잡 수준에 따라 동적으로 변함 
- (2) 부하에 민감하지 않은 알고리즘 
    - ex. RIP, OSPF, BGP

### 5.2.1 링크 상태 (LS) 라우팅 알고리즘 

- 네트워크 토폴로지와 모든 링크 비용이 알려져 있어서 링크 상태 알고리즘
- 각 노드가 자신과 직접 연결된 링크의 식별자와 비용 정보를 담은 링크 상태 패킷을 네트워크 상의 모든 노드로 브로드캐스트하게 함으로써 가능 
- 링크 상태 브로드캐스트 
    - 이를 통해 모든 노드는 네트워크에 대해 동일하고 완벽한 관점을 갖게 됨 
    ![image.png](attachment:ae231af0-022a-4539-91f9-bf56eedcde44:image.png)

##### 다익스트라 알고리즘 
- 하나의 노드에서 네트워크 내 다른 모든 노드로의 최소 비용 경로를 계산 
- 반복적이고, 알고리즘의 k번째 반복 이후에는 k개의 목적지 노드에 대해 최소 비용 경로가 알려짐 
- D(v): 알고리즘의 현재 반복 시점에서 출발지 노드부터 목적지 v까지의 최소 비용 경로의 비용 
- p(v): 출발지에서 v까지의 현재 최소 비용 경로에서 v의 직전 노드
- N' : 노드의 집합. 출발지에서 v까지의 최소 비용 경로가 명확히 알려져 있다면, v는 N'에 포함됨 

- 중앙 집중형 라우팅 알고리즘은 초기화 단계와 반복 부분으로 구성됨
- 반복 부분의 수행 횟수는 네트워크의 노드 수와 같음 

Initialization:
    N' = {u}
    for all nodes v
        if v is a neighbor of u
            then D(v) = c(u, v)
        else D(v) = infinity

Loop
    find w not in N' such that D(w) is a minimum
    add w to N'
    update D(v) for each neighbor v of w and not in N' :
        D(v) = min(D(v), D(w) + c(w,v))
        // new cost to v is either old cost to v or either old cost to v or known
        // least path cost to w plus cost w to v

Until N' = N
![image.png](attachment:e352a221-e7df-49fd-98a2-2e0e3aa6c496:image.png)
![image.png](attachment:c36d20f2-522f-4ce9-b3d2-2643307e7690:image.png)
- 알고리즘의 복잡도 : 최악의 경우 O(n^2)
- 단점 : 진동문제 발생 가능
    - 해결방법 1: 링크 비용이 해당 링크가 전달하는 트래픽의 양에 의존하지 않도록 함 
    - 해결방법 2: 모든 라우터가 동시에 링크 상태 알고리즘을 실행하지 못하도록 함 

### 5.2.2 거리 벡터 (DV) 라우팅 알고리즘

- 모든 정보를 가지고 시작하지 않음 
- 반복적이고 비동기적이고 분산적임 
    - 반복적 : 이웃끼리 더 이상 정보를 교환하지 않을 때까지 지속됨
    - 비동기적 : 모든 노드가 서로 정확히 맞물려 동작할 필요 없음
    - 분산적 : 직접 연결된 이웃으로부터 정보를 받고, 계산을 수행하며, 계산된 결과를 다시 그 이웃들에게 배포함

- 최소비용 => 벨만 포드 식을 사용 
- d_x(y) = min_v{c(x,v) + d_v(y)}

- 중간에 다른 이웃을 거쳐간다는 것을 전제로 함 
- 새로운 거리 벡터를 수신하면, x는 w의 거리 벡터를 저장하고 벨만 포드 식을 이용하여 자신의 거리 벡터를 갱신
![image.png](attachment:7dc91c2a-bcae-4d26-8891-6ea063fcee6d:image.png)
Initialization:
    for all destinations y in N:
        D_x(y) = c(x,y) // if y is not a neighbor then c(x,y) = infinity
    for each neighbor w
        D_w(y) = ? for all destinations y in N
    for each neighbor w
        send distance vector D_x = [D_x(y) : y in N] to w

Loop
    Wait (until I see a link cost change to some neighbor w or until I receive a distance vector from some neighbor w)

    for each y in N:
        D_x(y) = min_v {c(x,v) + D_v(y)}

if D_x(y) changed for any destination y
    send distance vector D_x = [D_x(y) : y in N] to all neighbors

forever
![스크린샷 2025-04-03 오후 4.46.48.png](attachment:57ccc58d-96cb-463d-b49f-a907f5c522ce:스크린샷_2025-04-03_오후_4.46.48.png)
![스크린샷 2025-04-03 오후 4.46.53.png](attachment:5c1d3384-e197-4bb8-877e-aefa386e439b:스크린샷_2025-04-03_오후_4.46.53.png)
![스크린샷 2025-04-03 오후 4.47.05.png](attachment:a7b4f006-8b6e-4e3d-9e80-7c8293848f5e:스크린샷_2025-04-03_오후_4.47.05.png)
![스크린샷 2025-04-03 오후 4.47.22.png](attachment:df8b8a17-c0af-423a-86f0-0542b9262c6a:스크린샷_2025-04-03_오후_4.47.22.png)
- 링크 비용 변경 -> 새로운 거리 벡터를 send -> 이를 가지고 필요하면 갱신

- 링크 비용이 올라가도 문제가 없을까?
    - 라우팅 루프가 발생할 수 있음 
    - count to infinity problem
    ![image.png](attachment:7342bb30-1e48-48b5-bcbe-d6faa0013c0a:image.png)
    - 해결방안 : 포이즌 리버스 
        - z가 y를 통해 목적지 x로 가는 경로 설정을 했다면, z는 y에게 x까지의 거리가 무한대라고 알림 

📊 링크 상태 알고리즘 vs 거리 벡터 알고리즘 — 3대 비교
항목            링크 상태 알고리즘 (OSPF 등)                거리 벡터 알고리즘 (RIP 등)
수렴 속도	            🔥빠름                                  🐢 느림
                전체 맵(LSDB)을 바탕으로                   이웃에게 정보를 하나씩 받아서, 
                Dijkstra 알고리즘을 바로 수행	            반복적으로 업데이트 필요

메시지 복잡성	        📈 높음                                    📉 낮음
                LSA(Link State Advertisement)를         거리 벡터만 이웃에게 주기적으로 보냄
                네트워크 전체에 플러딩 	

견고성 (루핑 회피)	    ✅ 강함                                     ❌ 약함
                자기 계산 기반                              count-to-infinity,
                → 루프 가능성 낮음	                        루프 발생 쉬움 (split horizon 등 보조 필요)

### 5.3 인터넷에서의 AS 내부 라우팅 : OSPF

- AS a.k.a 자율 시스템 (autonomous system)으로 라우터들을 조직화하여 관리 
- AS 내부 라우팅 프로토콜 (intra - autonomous system routing protocol)

##### 개방형 최단 경로 우선 (OSPF) 프로토콜 
- OSPF(open shortest path first)
- 링크 상태 정보를 플러딩하고 다익스트라 최소 비용 경로 알고리즘을 사용하는 링크 상태 알고리즘 
- 보안 : OSPF 라우터 간의 정보 교환을 인증할 수 있음 
    - 단순 인증 or MD5 인증 
- 하나의 목적지에 대해 동일한 비용을 가진 여러 개의 경로가 존재할 때 OSPF는 여러 개의 경로를 사용할 수 있도록 함 
- 유니 캐스트와 멀티캐스트 라우팅의 통합 지원 
- area로 구성될 수 있음 

### 5.4 인터넷 서비스 제공업자 (ISP) 간의 라우팅 : BGP
- 자율 시스템 간 라우팅 프로토콜 
- BGP (border gateway protocol) 경계 게이트웨이 프로토콜
- 거리 벡터 라우팅과 같은 줄기에서 나왔다고 볼 수 있는 분산형 비동기식 프로토콜 

#### 5.4.1 BGP의 역할 
- 패킷이 특정한 목적지 주소를 향해서가 아니라 CIDR 형식으로 표현된 주소의 앞쪽 프리픽스를 향해 전달됨 
- 이웃 AS를 통해 도달 가능한 서브넷 프리픽스 정보를 얻음 => 서브넷 주소 프리픽스로의 가장 좋은 경로 결정

#### 5.4.2 BGP 경로 정보 알리기 
- 라우터들은 게이트웨이 라우터 or 내부 라우터 
- BGP에서 라우터들의 쌍은 포트번호가 179이고 반영구적인 TCP연결을 통해 라우팅 정보를 교환 
- 외부 BGP 연결 : 2개의 as를 연결하는 bgp 연결
- 내부 BGP 연결 : 같은 as 내의 라우터 간 bgp 연결 

#### 5.4.3 최고의 경로 결정
- 주소 prefix를 알릴 때, 몇몇 BGP 속성을 함께 포함 
- BGP 속성
    - AS_PATH : 메시지가 통과하는 AS의 리스트 
    - NEXT-HOP : AS-PATH가 시작되는 라우터 인터페이스 IP 주소 
    - LOCAL_PREF ... etc

##### 뜨거운 감자 라우팅 
- AS 내부 라우팅 정보를 조사한 후, 이들 최소 비용 경로 중에서도 가장 적은 비용을 가진 경로를 선택 
- 전체 경로 중에서 자기 AS 외부에서 얼마의 비용이 들지는 신경쓰지 않고 오로지 자신의 AS 내부 비용만 줄이려는 알고리즘

##### 경로 선택 알고리즘 
- 지역 선호도를 미리 설정 or 학습
- 최고 지역 선호 값을 가진 경로를 선택 

##### IP 애니캐스트 
- 같은 콘텐츠를 지리적으로 분산된 다른 많은 서버에 복제 
- 각 사용자를 가장 가까운 서버의 콘텐츠로 접근하게 하려고 하는 경우 
- IP애니캐스트 설정 단계에서 자신의 서버 여러 대에 동일한 IP 주소를 할당하고 표준 BGP를 활용하여 이 주소를 서버 각각으로부터 알림
- 각 라우터는 라우팅 테이블을 설정하면서 BGP 경로 선택 알고리즘을 수행하여 해당 IP 주소로의 최고의 경로를 골라냄 
- CDN은 일반적으로 사용 X, DNS 시스템에서 잘 사용 

#### 5.4.5 라우팅 정책 
- 라우터가 목적지까지의 경로를 선택하려 할 때 AS 라우팅 정책은 최단 AS-PATH나 뜨거운 감자 라우팅 등의 다른 모든 고려사항보다 우선시됨 

#### 5.4.6 조각 맞추기 : 인터넷 존재 확인하기 