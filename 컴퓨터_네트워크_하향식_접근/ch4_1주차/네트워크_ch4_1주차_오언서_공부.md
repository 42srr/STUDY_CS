# Chapter4. 네트워크 계층: 데이터 평면

## 4.1 네트워크 계층 개요

### 4.1.1 포워딩과 라우팅: 데이터 평면과 제어 평면

네트워크 계층의 근본적인 역할: 송신 호스트에서 수신 호스트로 패킷 전달

### 중요한 기능 두 가지

| 개념     | 정의 | 실행 위치 | 실행 시간 | 실행 방식 |
|----------|----------------------------------------|----------------|------------|------------|
| 포워딩   | 패킷이 라우터의 입력 링크에 도달했을 때 적절한 출력 링크로 이동시키는 것 | 네트워크 계층의 데이터 평면 | 매우 짧음 (나노 초 단위) | 하드웨어 |
| 라우팅   | 송신자가 수신자에게 패킷을 전송할 때 패킷 경로를 결정하는 것 | 네트워크 계층의 제어 평면 | 비교적 김 (초 단위) | 소프트웨어 |


**포워딩 테이블**

- 라우터는 패킷 헤더의 특정 값을 보고 어디로 보낼지 결정
- 이 특정 값(보통 목적지 주소)을 포워딩 테이블에서 검색해서, 패킷을 어느 인터페이스로 내보낼지 찾음
- 네트워크 계층 프로토콜에 따라 헤더의 값이 목적지 주소일 수도 있고, 특정 연결을 나타내는 정보(IP 네트워크, MPLS 등)일 수도 있음

| 제어 평면 접근법 | 방식 | 라우터의 역할 | 포워딩 테이블 계산 | 라우팅 프로토콜 사용 |
|----------------|------------------------------|-----------------|--------------------|-----------------|
| 전통적 접근법  | 각 라우터에서 라우팅 알고리즘 실행 | 포워딩 + 라우팅 | 각 라우터가 개별적으로 계산 | O (라우팅 메시지 교환) |
| SDN 접근법     | 원격 컨트롤러가 라우터를 제어 | 포워딩만 수행 | 중앙 컨트롤러에서 계산 후 배포 | X (컨트롤러가 직접 설정) |

**원격 컨트롤러**

- 높은 신뢰성과 중복성을 갖춘 원격 데이터 센터에 설치될 수 있음
- ISP 혹은 다른 제3자에 의해 관리될 수 있다.

**라우터와 원격 컨트롤러 소통법**

- 포워딩 테이블과 그 밖의 라우팅 정보를 포함한 메시지를 교환함으로써 소통할 수 있다.

### 4.1.2 네트워크 서비스 모델

: 송수신 호스트 간 패킷 전송 특성 정의

- 보장된 전달: 패킷이 출발지 호스트에서 목적지 호스트까지 도착하는 것 보장
- 지연 제한 이내의 보장된 전달: 호스트 간 특정 지연 제한 안에 패킷 전달 보장
- 순서화 패킷 전달: 패킷이 목적지에 송신된 순서대로 도착하는 것 보장
- 최소 대역폭 보장: 송신 호스트가 비트들을 특정한 비트율 이하로 전송하는 한, 모든 패킷이 목적지 호스트까지 전달
- 보안 서비스: 네트워크 계층은 모든 데이터그램을 출발지 호스트에서는 암호화, 목적지 호스트에서는 해독할 수 있게 함 → 트랜스포트 계층의 모든 세그먼트에 대해 기밀성 유지

**최선형 서비스**

: 인터넷 네트워크 계층은 최선형 서비스 제공

- 패킷을 보내는 순서대로 수신됨을 보장할 수 x
- 목적지까지의 전송 자체도 보장할 수 x
- 종단 시스템 간 지연 보장 x
- 보장된 최소 대역폭 x

## 4.2 라우터 내부에는 무엇이 있을까?
**라우터의 네 가지 요소**

- 입력 포트
    - 라우터로 들어오는 패킷을 처리하는 첫 번째 단계
    - 패킷이 라우터에 도착하면 입력포트 → 스위치 → 출력포트 순서로 이동
    - 여기서 말하는 ‘포트’란?: 물리적인 입출력 라우터 인터페이스.
    - 실제로 라우터가 지원하는 포트의 수는 비교적 적은 수의 기업 라우터에서 수백 개의 10Gbps 포트를 갖는 ISP 가장자리의 라우터까지 다양함

	**입력 포트의 주요 기능**

	1. 물리 계층 기능
    	- 입력 포트의 맨 왼쪽 박스와 출력 포트의 맨 오른쪽 박스는 라우터로 들어오는 입력 링크로, 물리계층 기능(물리적인 신호인 0과 1을 받아들여 디지털 데이터로 변환) 수행
	2. 링크 계층 기능
    	- 미들박스: 들어오는 링크의 반대편에 있는 링크 계층과 상호 운용하기 위해 필요한 링크 계층 기능(MAC 주소 처리 등) 수행
	3. 포워딩 기능
    	- 입력포트 가장 오른쪽 박스: 입력 포트에서 포워딩 테이블을 참조하여 패킷의 경로 결정
    	- 스위치 구조를 통해 올바른 출력 포트로 패킷을 보냄
	4. 제어 패킷(라우팅 프로토콜 정보를 전달하는 패킷) 처리
    	- 제어패킷은 입력 포트에서 바로 라우팅 프로세서로 전달됨
    	- 일반 데이터 패킷은 출력 포트로 가지만, 제어 패킷은 라우팅 프로세서에서 직접 처리
	- 그 외에도 패킷의 버전 번호, 체크섬, TTL 필드를 확인하고 이후 두 필드를 다시 사용해야 한다. 
	- 또한 네트워크 관리에 사용되는 카운터(수신된 IP 데이터그램의 수) 갱신

- 스위치 구조
    - 라우터의 입력 포트와 출력 포트 연결
    - 스위치 구조는 라우터 내부에 포함(네트워크 라우터의 내부 네트워크)
- 출력 포트
    - 라우터가 패킷을 목적지로 보내기 전에 마지막으로 처리하는 곳
    
    **출력포트의 주요 기능**
    
    1. 패킷 저장
        - 스위치 구조에서 수신한 패킷을 일시적으로 저장
            
            → 네트워크 혼잡(출력 링크 사용량이 많을 때)으로 인해 패킷을 바로 못 보낼 수도 있기 때문
            
    2. 링크 계층 및 물리 계층 기능 수행
        - 링크 계층 기능
            - 패킷 헤더 추가, 오류검출 등
        - 물리 계층 기능(데이터 → 신호 변환)
            - 디지털 데이터를 신호로 변환해서 네트워크 케이블을 통해 전송
    3. 출력링크로 패킷 전송
        - 패킷을 출력 링크(출구)로 내보내는 단계
    4. 입출력 포트의 관계
        - 네트워크 장비는 보통 양방향 통신 지원
            - 하나의 네트워크 링크는 입출력 동시 처리 가능
        - 이 때, 출력 포트는 같은 링크의 입력 포트와 쌍을 이루어 동작하는 경우가 많음
            - ex) 라우터 A ↔ 라우터 B 로 연결된 케이블이 있다면
                - 라우터 A 의 출력 포트 = 라우터 B 의 입력 포트
                - 라우터 B 의 출력 포트 = 라우터 A 의 입력 포트
- 라우팅 프로세서
    - 제어 평면기능 수행
    - 기존의 라우터에서는 라우팅 프로토콜을 실행하고 라우팅 테이블에 있는 정보를 기반으로 패킷이 가야할 경로 계산. 링크 상태 정보와 라우팅 테이블을 유지관리하면서, 포워딩 테이블을 계산하여 패킷을 올바른 경로로 보낼 수 있게 함.
    - SDN 라우터에서 라우팅 프로세서는 라우팅 프로세서는 원격 컨트롤러와 통신하여 원격 컨트롤러에서 계산된 포워딩 테이블 엔트리를 수신하고 라우터의 입력 포트에 이러한 엔트리를 설치
    - 네트워크 관리 기능 수행

### 4.2.1 입력 포트 처리 및 목적지 기반 전송

**입력 패킷을 스위칭할 출력 포트가 각 패킷의 목적지 주소를 기반으로 하는 가장 간단한 경우**

**최장 프리픽스 매치 규칙**

- 목적지 IP 주소에 대한 라우팅 테이블을 조회할 때 가장 긴 접두사(prefix)를 가진 네트워크 주소와 일치하는 경로를 선택하는 방식

- 이 검색은 나노초 단위로 수행되어야 하므로 하드웨어에서 검색, 빠른 검색 알고리즘 필요

- 메모리 접속 시간에 특별한 주의를 기울여야 하므로 내장형 DRAM 과 빠른 SRAM 메모리가 있는 설계 필요

검색을 통해 패킷의 출력 포트가 결정되면 패킷을 스위치 구조로 보낼 수 있다. 일부 설계에서는 다른 입력포트로부터 패킷이 현재 구조를 사용하고 있다면 패킷이 스위칭 구조에 들어가는 것을 일시적으로 차단할 수 있다. 차단된 패킷은 입력 포트에 대기한 다음 나중에 구조를 교체하도록 예약된다. 

**매치 플러스 액션**: 주어진 패킷이나 데이터가 특정 조건(매치)에 맞을 때 수행하는 동작

### 4.2.2 스위칭

####  라우터 교환 방식 비교 표

| 교환 방식 | 특징 | 장점 | 단점 |
|-----------|------|------|------|
| **메모리를 통한 교환** | - CPU(라우팅 프로세서)가 직접 패킷을 처리 <br> - 입력 포트가 패킷을 CPU 메모리에 복사 후 출력 포트로 복사 <br> - 공유 시스템 버스로 인해 동시에 여러 패킷을 전달할 수 없음 | - 구조가 단순하고 구현이 쉬움 <br> - 일부 최신 라우터는 입력 라인 카드에서 목적지 주소를 검색하여 속도 향상 | - 메모리 대역폭에 의해 성능 제한 <br> - 최대 처리량은 메모리 대역폭의 절반(B/2) 이하 |
| **버스를 통한 교환** | - 입력 포트가 공유 버스를 통해 직접 출력 포트로 전송 <br> - 패킷이 특정 출력 포트와 매칭되도록 설계 <br> - 동시에 여러 패킷이 도착해도 한 번에 하나의 패킷만 전송 가능 | - CPU 개입 없이 패킷 전달 가능 <br> - 비교적 빠른 처리 속도 | - 모든 패킷이 동일한 버스를 거쳐야 하므로 병목현상 발생 <br> - 라우터의 교환 속도가 버스 속도에 의해 제한됨 |
| **상호 연결 네트워크를 통한 교환** | - 공유 버스의 대역폭 제한을 극복하기 위해 복잡한 상호연결 네트워크 사용 <br> - 크로스바 스위치: 여러 패킷을 병렬로 전달 가능 <br> - 다단계 스위치 구조: 패킷을 작은 청크로 나누어 병렬 처리 가능 | - 여러 패킷을 동시에 전달 가능 (크로스바 스위치) <br> - 다단계 구조를 활용하면 동일 출력 포트로의 패킷 충돌 완화 가능 | - 크로스바 스위치에서도 동일한 출력 포트로 동시에 패킷이 오면 대기 발생 <br> - 다단계 스위치 구조는 설계 및 구현이 복잡 |

### 4.2.4 어디에서 큐잉이 일어날까?

- R_line: 입력 및 출력 라인의 속도. 즉, 패킷이 입력포트에서 들어오거나 출력포트에서 나가는 속도
    - 초 당 R_line 패킷

- R_switch: 스위치 내부에서 패킷이 이동하는 속도. 즉, 입력포트에서 출력 포트로 패킷을 전달하는 속도.

- 만약 스위치 속도(R_switch)가 입출력 라인 속도(R_line)의 N 배라면, 큐잉이 발생하지 않음!
    - 왜냐하면 최악의 경우, 모든 입력포트 N 개가 한 번에 패킷을 받아도, 스위치가 R_line 보다 N 배 빠르면 다음 패킷이 오기 전에 모든 패킷을 처리할 수 있기 때문

#### 입력 큐잉

- 출력 포트가 다르다면 여러 패킷이 병렬로 전달될 수 있지만, 두 패킷이 같은 출력 큐로 향한다면 이 중 한 패킷은 차단되고 입력 큐에서 기다려야 한다.
- HOL(head of the line) 차단(블로킹): 출력 링크가 경쟁이 없는 상태이지만 라인 앞쪽에서 다른 패킷이 막고 있는 상태여서 스위치 구조를 통해 전송되기 위해 기다려야 하는 상태

#### 출력 큐잉

- 패킷 도착 속도는 패킷이 전달될 수 있는 속도를 일시적으로 초과하며, 불일치가 지속되는 시간이 길어질 수록 큐는 더 길어지며, 결국 포트의 버퍼가 가득 차서 들어오는 패킷을 저장할 메모리가 충분하지 않음
- 도착한 패킷을 삭제하거나 이미 대기중인 하나 이상의 패킷을 제거해야 함
- 들어오는 경우에는 버퍼가 가득 차기 전에 패킷을 삭제(또는 헤더를 마킹)하여 송신자에게 혼잡 신호를 제공하는 것이 바람직할 수 있다.
    - 헤더 마킹: 명시적 혼자 알림 비트 사용
- AQM 알고리즘으로 알려진 많은 패킷 삭제와 패킷 마킹 정책이 제안되거나 분석되고 있음
    - RED(Random Early Detection)
    - PIE(Proportional Integral controller Enhanced)
- 패킷 스케줄러: 전송 대기 중인 패킷 중 하나의 패킷 선택

#### 얼마나 많은 버퍼가 요구되는가?

- 과거에는 네트워크가 RTT * C(링크 용량) 만큼의 버퍼가 필요하다고 생각함
- 요즘은 B = RTT × C / √N 라고 생각함
    - TCP 흐름이 많으면 버퍼를 더 작게 잡아도 됨

- 버퍼블로트
    - 버퍼가 너무 크면 오히려 문제가 생김
    - 패킷의 과도한 버퍼링으로 인해 생기는 패킷 교환 네트워크의 높은 대기 시간의 원인
    - 처리량뿐만 아니라 최소 지연도 중요하며 네트워크 가장자리와 네트워크 내 큐에서 송신작 간의 상호작용이 실제로 복잡하고 미묘할 수 있음을 보여줌

### 4.2.5 패킷 스케줄링

#### FIFO

- 출력 링크 큐에 도착한 동일한 순서로 출력 링크에서 전송할 패킷 선택

#### 우선순위 큐잉

- 패킷이 네트워크 장비에 도착하면, 우선순위를 기준으로 그룹이 나누어진다
- 네트워크 운영자가 **네트워크극 제어하는 중요한 정보(관리 패킷)**를 일반 사용자 트래픽보다 우선순위가 높도록 설정할 수 있다.
- 예를 들면, 네트워크 관리 메시지(ex) 라우터 설정 변경, 장애 감지 신호 등)를 일반 웹 서핑보다 먼저 보내도록 설정
- 비선점 우선순위 큐잉: 한 번 시작된 작업이 끝날 때까지, 더 높은 우선순위의 작업이 와도 방해받지 않는 큐잉 방식

#### 라운드 로빈과 WFQ

**라운드로빈**

- 패킷은 우선순위 큐잉과 같이 클래스로 분류
    - 그러나 클래스 간에는 엄격한 서비스 순위 존재 x
    - 스케줄러가 클래스 간에 서비스를 번갈아서 제공
- **작업 보존 큐잉 규칙**: 전송할 패킷이 큐에 있으먄, 네트워크 링크가 절대 유휴 상태(아무것도 하지 않는 상태)가 되지 않도록 하는 규칙

**WFQ**: 가중치를 기반으로 네트워크 대역폭을 공정하게 나누는 스케줄링 방식

**라운드로빈과의 차이**

- 라운드로빈: 모든 패킷이 동일한 서비스 시간을 받음
- WFQ: 각 클래스마다 가중치를 부여하여, 중요도가 높은 패킷이 더 많은 서비스 시간을 가짐

**WFQ 의 핵심 개념**

- 네트워크에서 여러 개의 패킷 클래스가 있다면,
- 각 클래스마다 가중치 w_i 를 정해놓고,
- 총 대역폭(전송률 R)을 가중치 비율대로 나눠서 보장해줌
    - 각 클래스 i 의 대역폭 비율: w_i / ∑w_j
        - 여기서 분모는 전송을 위해 큐에 패킷이 있는 모든 클래스의 합
    - 링크 전송률이 R 이라면, 클래스 i 는 최소 R * w_i / ∑w_j 만큼의 처리율을 가짐

**WFQ 의 한계점**

- 이론적으로는 완벽한 비율 기반 대역폭 분배 가능
- 하지만, 실제 네트워크에서는 패킷 크기와 전송 순서 문제때문에 100 % 이상적으로 동작하지 않음