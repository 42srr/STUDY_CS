## 2.4 DNS: 인터넷의 디렉터리 서비스

호스트를 식별자의 종류 : 어떤 것으로 호스트를 식별할 것인가?
- 호스트 이름(hostname)
    - ex. www.google.com
    - 호스트 위치에 대한 정보는 거의 제공하지 x 
    - 가변 길이의 알파뉴메릭 문자로 구성
- IP 주소(IP address)
    - 4바이트로 구성
    - 계층구조를 가짐
    - 주소를 왼쪽으로 오른쪽으로 조사해서 위치 정보를 얻을 수 있음
    - 라우터가 처리하기에 용이함

### 2.4.1 DNS가 제공하는 서비스 

main idea : 사람은 호스트 이름이 편하고, 라우터는 IP주소가 편한데.. 어떻게 하지?
=> boom. answer : 호스트 이름을 IP 주소로 변환하는 서비스를 만들자!

#### 인터넷 DNS (domain name system)
- 호스트 이름을 IP 주소로 변환해주는 디렉토리 서비스

##### DNS is..
- DNS 서버들의 계층 구조로 구현된 분산 데이터서비스
- 호스트가 분산 데이터베이스로 질의하도록 허락하는 애플리케이션 계층 프로토콜

- DNS 서버는 주로 BIND(Berkeley Internet NAme Domain) 소프트웨어를 수행하는 유닉스 컴퓨터
- DNS 프로토콜은 UDP상에서 수행되고 포트번호 53 이용 
- DNS는 다른 애플리케이션 프로토콜들이 HTTP, SMTP, FTP 등 사용자가 제공한 호스트 이름을 IP주소로 변환하기 위해 주료 이용 

##### DNS의 추가 서비스 
- 호스트 에일리어싱(host aliasing)
    - 호스트는 정식 호스트 이름(canonical hostname)을 가지는데 이것보다 기억하기 쉬운 별칭들을 가질 수 있음
        - 정식 호스트 이름 ex. relay1.west-coast.enterprise.com
        - 별칭           ex. enterprise.com, www.enterprise.com (별칭은 여러개 존재 가능)
- 메일 서버 에일리어싱(mail server aliasing)
    - DNS는 호스트의 IP주소뿐만 아니라 제공된 별칭 호스트 이름에 대한 정식 호스트 이름을 얻기 위해 메일 애플리케이션에 의해 수행됨
- 부하 분산(load distribution)
    - 한 사이트는 여러 서버에 중복되어 있을 수 있음 
        - 여러 서버는 각각 다른 종단 시스템에서 수행되고, 다른 IP 주소를 가짐 
        - DNS는 이 IP주소 집합을 가지고 있음 
        - 호스트 이름에 대한 질의를 하면, 이 집합에서 순환식으로 주소를 응답함
        - 트래픽을 분산하는 효과 

#### 2.4.2 DNS 동작 원리 개요
- DNS가 어떻게 호스트 이름을 IP 주소로 변환하는지에 초점을 맞추어.. 

- 애플리케이션 ----host 이름 -----> DNS 클라이언트 호출 
- 모든 DNS 질의, 응답 메시지는 포트 53의 UDP 데이터그램으로 보내짐

- 그럼 DNS 설계를 이렇게 하면 되지 않나? 
    -> 모든 매핑(호스트 이름 - IP 주소) 정보를 가지고 있는 하나의 큰 네임 서버 
        -> 이 서버에 많은 클라이언트가 질의하는 형태
- 아쉽게도.. 좋은 설계가 아님. 
    - 서버 고장, 트래픽양, 거리문제로 인한 지연(멀면.. 지연이 생기니), 유지관리(모든 정보를 유지할 수 X, 관련 인증문제도 있음)
    -> 한마디로 요약하면 확장성이 전혀 없다. 

##### 분산 계층 데이터베이스 

ex. www.amazon.com 검색
-> 계층 구조를 통해 탐색

www.amazon.com
                 (로컬 DNS 서버)
                  www.amazon.com의 IP 주소가 캐싱되어 있니?
                  -> 있으면 IP주소 반환
                  -> 없으면 루트 DNS 서버에 넘겨줌 
                <---
              |
             'com' 관리하는 최상위 레벨 도메인 서버로 가렴
             <---
          |
          'www.amazon.com'을 관리하는 책임 DNS 서버로 가렴
          <---
    |
    -> 책임 DNS 서버로 가면 해당 IP주소를 알려줌

- (1) 루트 DNS 서버
- (2) 최상위 레벨 도메인 서버 (TLD, TOP LEVEL DOMAIN)
    - gTLD(generic TLD) : .com, .org, .net 등
    - ccTLD (country-code TLD) : .kr, .us, .uk
- (3) 책임 DNS 서버  

- 질의는 재귀적 질의, 반복적 질의 두 가지 방법으로 이루어질 수 있음

##### DNS 캐싱
- 질의에 대한 응답을 받을 때마다 로컬 메모리에 정보를 저장할 수 있음 
- 다른 DNS 서버로의 질의 없이 바로 응답 가능

#### 2.4.3 DNS 레코드와 메시지 
- 자원 레코드 (RR = resource record)
    - 호스트 이름을 IP 주소로 매핑하기 위해 사용
    - DNS 데이터 단위
- 자원 레코드는 4개의 튜플 (tuple)로 구성됨 
    - 튜플 : 여러 개의 필드로 이루어진 데이터 구조
- 자원 레코드의 필드 (Name, Value, Type, TTL)
    - Type (name, value는 type에 따라 달라짐)
        - Type = A
            - Name은 호스트 이름
            - Value는 IP wnth 
        - Type = NS
            - Name은 도메인
            - Value는 도메인 내부의 호스트에 대한 IP주소를 얻을 수 있는 방법을 아는 책임 DNS 서버의 호스트 이름
        - Type = CNAME
            - Name은 별칭 호스트 이름
            - Value는 정식 호스트 이름
        - Type = MX
            - Name은 별칭 호스트 이름
            - Value는 메일 서버의 정식 이름 
    - TTL : 자원 레코드의 생존기간
        : 자원이 캐시에서 제거되는 시간을 결정 

##### DNS 메시지 

기본 구조
+---------------------------+
|        HEADER (12 byte)   |
+---------------------------+
|      QUESTION SECTION     |
+---------------------------+
|      ANSWER SECTION       |
+---------------------------+
|   AUTHORITY SECTION       |
+---------------------------+
|   ADDITIONAL SECTION      |
+---------------------------+

- (1). 헤더 12바이트 (식별자, 플래그, 카운트 필드로 구성)
    - [1] 식별자 (2바이트)
        : 어떤 요청인지, 어떤 요청에 대한 응답인지 식별
        : ID값이 같으면 같은 요청 관련한 것
    - [2] 플래그 (2바이트)
        - QR (1 비트)
            - 0이면 질의 1이면 응답
        - Opcode (4 비트)
            - 어떤 타입의 질의인지 구분
        - AA (1 비트)
            - 권한 DNS 서버에서 온 응답인지 확인
        - TC (1 비트)
            - 메시지가 너무 커서 잘렸으면 1
        - RD (1 비트)
            - 클라이언트가 재귀 질의를 요청했으면 1
        - RA (1 비트)
            - 서버가 재귀 질의를 지원하면 1 
        - Z (3 비트)
            - 사용안하는 필드(항상 0)
        - RCODE (4 비트)
            - 응답 상태 코드 (ex. 0 정상 3 NXDOMAIN 등)
    - [3] 카운트 필드 (8 바이트)
        - QDCOUNT (2 바이트)
            - 질의 개수
        - ANCOUNT (2 바이트)
            - 응답 레코드 개수
        - NSCOUNT (2 바이트)
            - 권한 정보 레코드 개수
        - ARCOUNT (2 바이트)
            - 추가 정보 레코드 개수 

- 등록기관을 통해 데이터베이스에 레코드를 넣음 

##### DNS 보안 취약점 

- DNS가 인터넷에 중요한 역할을 수행하기 때문에, 공격을 받으면 위험
- 그럼 어떤 공격들이 있을 수 있을까?

- (1) DDos 대역폭 플러딩 공격
    - 공격자가 다량의 패킷을 각 DNS 루트 서버로 보냄
        => 정상적인 질의가 응답 받는 것을 방해
    - 해결 방안 : 루트 서버가 공격 메시지를 블록
    - 그리고.. 대부분의 로컬 서버는 최상위 도메인 서버를 캐싱하고 있어서 루트 서버를 안 거칠 수 있음.. 그럼 루트 서버에 대한 공격이 의미가 없어짐
- (2) 모든 최상위 도메인 서버 공격
    - 루트 서버처럼 우회하는 것이 쉽지 않음
- (3) 중간자 공격
    - 호스트로부터의 질의를 가로채어 가짜 응답 반환
- (4) DNS 중독 공격
    - DNS 서버로 가짜 응답을 보내서 가짜 레코드를 캐싱하게끔 

- 공격을 막아내기 위해 DNS 보안 확장 프로토콜이 개발되어 사용되고 있음 

## 2.5 P2P 파일 분배
- P2P 구조는 항상 켜져있는 인프라스트럭쳐 서버에 최소한으로 의존
- P2P 구조에서 피어들은 서버의 분배 프로세스를 도울 수 있음

##### P2P 구조의 자가 확장성
(클라이언트 - 서버 구조와의 비교를 통해)

**용어정리**

U_s = 서버의 접속 링크 업로드 속도
U_i = i번째 피어의 접속 링크 업로드 속도
d_i = i번째 피어의 접속 링크 다운로드 속도
F(단위 비트) = 분배되는 파일의 크기
N = 파일의 복사본을 얻고자 하는 피어들의 수
분배 시간 (distribution time) = 모든 N개의 피어들이 파일의 복사본을 얻는데 걸리는 시간 


##### <클라이언트-서버 구조>
- 전송해야 하는 파일 총 크기 : F * N
- 분배하는 시간 = 총 크기 / 서버 업로드 속도 (=U_s)
- d_min (가장 낮은 다운로드 속도를 가진 피어의 다운로드 속도)
- 최소 분배 시간 : F / d_min

=> D_cs >= max{NF/U_s, F/d_min}

- 피어의 수에 따라 분배시간은 선형적으로 증가

##### <P2P 구조>
- 분배 시간은 각 피어가 다른 피어들에게 파일의 일부를 어떻게 분베하느냐에 달려 있음

최소 분배 시간을 구하려는 3가지 관찰
- 최소 분배 시간 : F / U_s
    => why? 서버가 한번만 파일을 보내면 되니까 
        => why? 피어들이 서로 파일을 재분배할 수 있기 때문
- 최소 분배 시간 : F / d_min
    -> 다운로드 속도가 가장 느린 피어를 고려
- 최소 분배 시간 : (N * F) / U_total
   -> 시스템의 전체 업로드 용량 (=U_total) = U_s + U_1 + U_2 + ... + U_N 고려

=> D_p2p >= max{F/U_s, F/d_min, (N*F)/U_total}

##### 비트토렌트 
- 토렌트 : 특정 파일의 분배에 참여하는 모든 피어의 모임
- 토렌트에 참여하는 피어들은 서로에게서 같은 크기의 청크를 다운로드함
    - 일반적인 청크의 크기 256 킬로바이트 
- 각 토렌트는 트래커(tracker) 인프라스트럭처 노드를 갖고 있음 
    - 피어가 토렌트에 가입할 때 트레커에 자신 등록, 주기적으로 생존신고
- 이웃 피어 
    - 한 피어가 성공적으로 TCP 연결을 설정한 모든 피어

파일 분배 과정 
- 가입 -> 트래커에 등록
- 트래커가 토렌트에 참여하고 있은 피어들 중 임의로 부분집합을 선택하여 피어에게 IP 주소 목록 전송
- 피어가 목록에 있는 모든 피어와 TCP 연결 설정
- 주기적으로 이웃 피어들에게 그들이 갖고 있는 청크 목록 요구 
- 이제부터, 어떤 피어에게 어느 청크를 먼저 요구할 지 선택
    - *가장 드문 것 먼저*
    - *가장 빠른 속도로 제공하는 이웃에게 먼저*
- 현명한 교역
    - 5개의 피어와 교역하고, 이 교역하는 피어들 외에는 비활성화 
    - 4개는 가장 빨리 제공해주는 피어 선택
    - 1개는 임의로 선택 (낙관적으로 활성화)
- 비트토렌트의 다른 기법
    - 조각, 파이프라이닝, 무작위 우선 선택, 마지막 게임 모드, 안티스너빙

## 2.6 비디오 스트리밍과 콘텐츠 분배 네트워크 

### 2.6.1 인터넷 비디오 
- 비디오는 이미지의 연속으로, 압축되어 전송
- 압축되지 않은 디지털 인코딩된 이미지는 픽셀 단위로 구성, 각 필셀은 휘도와 색상을 나타내는 여러 비트들로 인코딩
- 비디오 품질과 비트 전송률은 서로 반비례 
- 스트리밍 비디오에서 가장 중요한 성능 척도는 평균 종단 간 처리량 

### 2.6.2 HTTP 스트리밍 및 DASH
- HTTP 스트리밍에서 비디오는 HTTP 서버 내의 특정 URL을 갖는 일반적인 파일로 저장됨
- 시청을 원할 시, 클라이언트는 서버에게 TCP 연결을 설립하고 해당 URL에 대한 HTTP GET 요청을 발생시킴
- 재생 시작 조건 : 애플리케이션 버퍼에 전송된 바이트 수가 미리 정해진 임곗값을 초과하면
- DASH
    - 여러 가지 버전으로 인코딩 (각 버전은 비트율과 품질 수준이 다름)
    - 측정된 수신 대역폭과 비트율 결정 알고리즘을 통해 매번 다른 버전의 데이터를 요청

### 2.6.3 콘텐츠 분배 네트워크 CDN
- 다수 지점에 분산된 서버 운영 
- 비디오 및 다른 형태의 웹 콘텐츠 데이터의 복사본을 이러한 분산 서버에 저장
- 사설 CDN, 제 3자가 운영하는 CDN이 있음 

- 서버의 위치를 어디에 둘 것인지에 대한 2가지 철학
    - Enter Deep
    - Bring Home

- CDN 동작
    - 재생 요청을 가로채 그 시점에서 가장 적당한 CDN 클러스터 선택, 클라이언트의 요청을 해당 클러스터의 서버로 연결 

- 요청을 어떻게 가로채는지?
    - DNS를 활용 

- 클러스터 선택 정책
    - 지리적으로 가장 가까운 클러스터 선택
    - 실시간 측정하여 선택
        - 클라이언트 간의 지연 및 손실 성능에 대해 

## 2.7 소켓 프로그래밍 : 네트워크 애플리케이션 생성 
- 알려진 프로토콜을 이용할 수도, 자신만의 프로토콜을 이용할 수도 있음
### 2.7.1 UDP를 이용한 소켓 프로그래밍 
- 서버는 특정 포트에서 대기하며 클라이언트의 데이터를 수신함
- 클라이언트는 서버로 데이터를 바로 전송 (연결과정 x)
- 서버는 클라이언트의 IP와 포트를 확인하고 응답을 보냄 
### 2.7.2 TCP 소켓 프로그래밍 
- 서버는 특정 포트에서 대기하면서 클라이언트의 연결 요청을 받음
- 클라이언트가 서버에게 연결 요청을 보냄
- 서버가 요청을 수락하면 연결 확립
- 데이터를 주고 받으며 통신
- 통신이 긑나면 연결을 닫음 