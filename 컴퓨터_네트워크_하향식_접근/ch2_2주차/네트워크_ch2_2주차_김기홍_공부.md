### 2.4. DNS: 인터넷의 디렉터리 서비스

**호스트 이름(hostname)** : www.facebook.com | www.google.com | gaia.cs.umass.edu 등, 사용자가 기억하기 쉽지만 위치에 대한 정보를 거의 제공하지 않고 라우터가 처리하기도 곤란함

이런 이유로 호스트는 흔히 말하는 **IP 주소(IP address)** 로도 식별된다.

#### 2.4.1 DNS가 제공하는 서비스

**DNS(domain name system)** : 호스트 이름을 IP 주소로 변환 해주는 디렉터리 서비스 (BIND(Berkeley Internet Name Domain) 소프트웨어를 수행하는 유닉스 컴퓨터)

DNS 프로토콜은 UDP 상에서 수행되고 포트 번호 53을 이용한다.

수행하는 순서:

1. 같은 사용자 컴퓨터는 DNS 애플리케이션이 클라이언트 측을 수행한다.
2. 브라우저는 URL로부터 호스트 이름 www.someschool.edu 를 추출하고 그 호스트 이름을 DNS 애플리케이션의 클라이언트 측에 넘긴다.
3. DNS 클라이언트는 DNS 서버로 호스트 이름을 포함하는 질의를 보낸다.
4. DNS 클라이언트는 결국 호스트 이름에 대한 IP 주소를 가진 응답을 받게 된다.
5. 브라우저가 DNS 로부터 IP 주소를 받으면, 브라우저는 해당 IP 주소와 그 주소의 80번 포트에 위치하는 HTTP 서버 프로세스로 TCP 연결을 초기화한다.

DNS 는 호스트 이름을 IP 주소로 변환하는 것 외에 다음과 같은 중요한 추가 서비스를 제공한다.

- 호스트 에일리어싱(host aliasing)
- 메일 서버 에일리어싱(mail server aliasing)
- 부하 분산(load balancing)

#### 2.4.2 DNS 동작 원리 개요

여기서는 호스트 이름을 IP 주소로 변환하는 서비스에 초점을 맞춘다.

어떤 사용자 호스트에서 실행되는 앱이 호스트 이름을 IP 주소로 변환하려 한다고 가정했을 때

그 앱은 변환될 호스트 이름을 명시해서 DNS 측의 클라이언트를 호출할 것이다. (getbyhostname() 함수)

그리고 사용자의 호스트의 DNS는 요청한 매핑에 해당하는 DNS 응답 메시지를 받는다.

이제 이 매핑은 호출한 앱으로 전달된다.

그러므로 사용자 호스트의 호출한 애플리케이션 관점에서 DNS는 간단하고 직접적인 변환 서비스를 제공하는 블랙박스다.


DNS 는 분산되도록 설계되었다. (DNS는 분산 데이터베이스가 인터넷에서 어떻게 구현될 수 있는지를 보여주는 훌륭한 사례다.)

만약 DNS가 중앙집중화 되었다면 다음 문제를 겪을 것이다.

- 서버의 고장 <- 전체 인터넷이 적동하지 않음
- 트래픽 양 <- 단일 DNS 서버가 모든 DNS 질의를 처리해야 한다. (수많은 호스트에서 발생한 모든 HTTP 요청과 전자메일 메시지의 처리)
- 먼 거리의 중앙 집중 데이터베이스 <- 단일 DNS 서버가 모든 질의 클라이언트로부터 '가까울' 수만은 없다.
- 유지관리 <- 단일 네임 서버는 모든 인터넷 호스트에 대한 레코드를 유지해야 하는데, 이 중앙 집중 데이터베이스는 거대해지고 모든 새로운 호스트를 반영하기 위해 자주 갱신해야만 한다. 또한 중앙 집중 데이터베이스에 호스트를 등록할 수 있도록 사용자에게 허용하는 것과 관련된 인증 문제가 있다.


**분산 계층 데이터베이스**

확장성 문제를 다루기 위해 DNS는 많은 서버를 이용하고 이들을 계층 형태로 구성하며 전 세계에 분산시킨다.

1. 루트 DNS 서버: 1000개 이상의 루트 서버 인스턴스가 전 세계에 흩어져 있다. 루트 서버들은 13개의 다른 루트 서버 복사체이고, 12개의 다른 기관에서 관리되며, 인터넷 할당 번호 관리기관에 의해 조정된다. 루트 네임 서버들과 이를 관리하는 기관과 그들의 IP 주소 목록은 [Root Servers 2020(?)] 에서 볼 수 있다.
2. 최상위 레벨 도메인(Top-level domain): 상위 레벨 도메인(com,m org, net, edu, gov), 모든 국가의 상위 레벨 도메인(kr, uk, fr, ca, jp) 같은 모든 국가의 상위 레벨 도메인에 대한 TLD 서버(또는 서버 클러스터)가 있다.
3. 책임 DNS 서버: 대부분의 대학과 큰 기업들은 자신의 기본 책임 DNS 서버와 보조 책임 DNS 서버를 유지하고 구현한다. 인터넷에서 접근하기 쉬운 호스트를 가진 모든 기관은 호스트 이름을 IP 주소로 매핑하는 공개적인 DNS 레코드를 제공해야 한다. 기관의 책임 DNS 서버는 이 DNS 레코드를 갖고 있다. 또한 기관은 이 레코드를 갖도록 자신의 책임 DNS 서버의 구현을 선택할 수 있고, 일부 서비스 제공자의 책임 DNS 서버에 이 레코드를 저장하도록 비용을 지불한다.

그림 19와 20의 차이가 생기는 이유가 뭐지?

#### 2.4.3 DNS 레코드와 메시지

**DNS캐싱** : 질의 사슬에서 DNS 서버가 DNS 응답을 받았을 때 이를 로컬 메모리에 응답에 대한 정보를 저장할 수 있다.

DNS 분산 DB를 구현한 DNS 서버들은 호스트 이름을 IP 주소로 매핑하기 위한 **자원 레코드(resource record, RR)** 를 저장한다. 자원 레코드는 다음과 같은 필드를 포함하는 4개의 튜플(tuple)로 되어 있다.

`(Name, Value, Type, TTL)`

- TTL : 생존기간(time to live)
- Type=A:
  - Name: 호스트 이름
  - Value: 호스트 이름에 대한 IP 주소
- Type=NS:
  - Name: 도메인
  - 책임 DNS 서버의 호스트 이름
- Type=MX
  - Value: 별칭 호스트 이름 Name 을 갖는 메일 서버의 정식 이름

**DNS 메시지**

- 헤더 영역(첫 12 바이트): 식별자, 플래그, 질문의 수, 답변 RR의 수, 추가 RR의 수, 추가 RR의 수
- 질문 영역(question section): (1) 질의 되는 이름을 포함하는 이름 필드, (2) 이름에 대해 문의되는 질문 타입을 나타내는 타입 필드를 포함
- DNS 서버로부터의 응답에서 답변 영역: 원래 질의된 이름에 대한 자원 레코드를 포함
- 책임 영역(authority section): 다른 책임 서버의 레코드를 포함
- 추가 영역(additional section): 도움이 되는 다른 레코드 (MX 질의에 대한 응답에서 전자메일 서버의 정식 호스트 이름을 제공하는 자원 레코드, 메일 서버의 정식 호스트 이름에 대한 IP 주소를 제공하는 Type A 레코드 등)

### 2.5 P2P 파일 분배

P2P 구조는 항상 켜져 있는 인프라 스트럭쳐 서버에 최소한으로 의존하거나 전혀 의존하지 않는다. 대신 간헐적으로 연결되는 호스트 쌍들(피어라고 부름)이 서로 통신한다. 피어는 서비스 제공자가 소유하는 것이 아니라 사용자가 제어하는 데스크톱과 랩톱, 스마트폰이 소유한다.

**P2P 구조의 확장성**

클라이언트-서버 구조는 전송해야 하는 호스트가 늘어나면 파일 전송 시간이 선형적으로 늘어나지만 P2P 구조는 피어가 늘어날 수록 log N 으로 늘어난다.

**비트토렌트** : 파일 분배를 위한 인기 있는 P2P 프로토콜

### 2.6 비디오 스트리밍과 콘텐츠 분배 네트워크


#### 2.6.1 인터넷 비디오

비디오는 일반적으로 초당 24개 혹은 30개 이미지로 일정한 속도로 표시된다.

비디오 품질과 비트 전송률은 서로 반비례한다. 오늘날의 상용 압축 알고리즘은 근본적으로 원하는 모든 비트 전송률로 비디오를 압축할 수 있다. 물론 비트 전송률이 높을수록 이미지 품질이 좋아지고 전반적인 사용자 시청 환경이 향상된다.

인터넷 비디오는 일반적으로 고화질 동영상을 스트리밍 하기 위해 100 kbps 에서 4 Mbps 이상으로 구성된다. 4K 스트리밍은 10 Mbps 이상의 비트 전송률로 예상된다.

지금까지 스트리밍 비디오에서 가장 중요한 성능 척도는 평균 종단 간 처리량이다. 연속재생을 제공하기 위해, 네트워크는 압축된 비디오의 전송률 이상의 스트리밍 애플리케이션에 대한 평균 처리량을 제공해야 한다.

또한 압축을 사용하여 동일한 비디오를 여러 버전의 품질로 만들 수 있다. ex. 300kbps, 1Mbps, 3Mbps 의 속도로 동일한 비디오의 세 가지 버전을 만들 때 압축을 사용할 수 있다. (화질에 따라 선택 가능)

#### 2.6.2 HTTP 스트리밍 및 DASH

클라이언트가 서버에게 HTTP GET 요청을 발생하면 서버가 기존 네트워크 프로토콜 및 트래픽 조건이 허용되는 대로 HTTP 응답 메시지 내에서 비디오 파일을 전송한다.

모든 클라이언트가그들 사이의 가용 대역폭의 차이에도 불구하고 똑같이 인코딩된 비디오를 전송받는 문제를 피하기 위해 새로운 형태의 HTTP 기반 스트리밍인 **DASH(Dynamic Adaptive Streaming over HTTP)** 가 개발되었다. DASH에서 비디오는 여러 가지 버전으로 인코딩 되며, 각 버전은 비트율과 품질 수준이 다르다. 클라이언트는 동적으로 서로 다른 버전의 비디오를 몇 초 분량의 길이를 갖는 비디오 조각(chunk) 단위로 요청한다. 클라이언트는 HTTP GET 요청을 이용해 다른 버전의 비디오 조각을 매번 선택한다.

DASH를 사용할 때, 각 비디오 버전은 HTTP 서버에 서로 다른 URL 을 가지고 저장된다. HTTP 서버는 비트율에 따른 각 버전의 URL을 제공하는 **메니페스트 파일(manifest file)**을 갖고 있다. 클라이언트는 먼저 메니페스트 파일을 요청하여 서버에서 제공되는 다양한 버전을 알게 되고, 클라이언트는 매번 원하는 버전의 비디오 조각 단위 데이터를 선택하여 HTTP GET 요청 메시지에 URL과 byte-range 를 지정하여 요청한다. 비디오 조각 단위 데이터를 다운로드 하는 동안에 클라이언트는 측정된 수신 대역폭과 비트율 결정 알고리즘을 이용해 다음에 선택할 비디오 조각 단위 데이터의 버전을 결정한다.

#### 2.6.3 콘텐츠 분배 네트워크(CDN)

전 세계의 사용자들에게 엄청난 양의 비디오 데이터를 분배하는 문제를 해결하기 위해 거의 대부분의 비디오 스트리밍 회사들은 **콘텐츠 분배 네트워크(Content Distribution Network, CDN)** 를 이용한다. CDN은 다수의 지점에 분산된 서버들을 운영하며, 비디오 및 다른 형태의 웹 콘텐츠 데이터이ㅡ 복사본을 이러한 분산 서버에 저장한다.

CDN 은 일반적으로 서버의 위치에 대해 다음 두 가지 철학 중 하나를 채용하고 있다.

- Enter Deep
- Bring Home

#### 2.6.4 사례연구: 넷플릭스, 유튜브

- 콘텐츠 수집
- 콘텐츠 처리
- CDN으로의 버전 업로드

### 2.7 소켓 프로그래밍: 네트워크 애플리케이션 생성

#### 2.7.1 UDP를 이용한 소켓 프로그래밍

#### 2.7.2 TCP 소켓 프로그래밍

### 2.8. 요약
