# 3.5 연결지향형 트랜스포트: TCP

## 3.5.1 TCP 연결

> 💡 TCP는 애플리케이션 프로세스가 데이터를 다른 프로세스에게 보내기 전에, 두 프로세스가 서로 '핸드셰이크'를 먼저 해야 하므로 연결지향형(connection-oriented)임.
> 

즉, 데이터를 안전하게 전송하기 위한 조건들을 설정하기 위해, 사전 세그먼트를 보내야 함.

TCP `연결`은 **두 통신 종단 시스템의 TCP 상태를 공유**하는 논리적인 연결임. 또한, `전이중 서비스(full-duplex service)`를 제공함.

> 만약 호스트 A의 프로세스와 호스트 B의 프로세스 사이에 TCP 연결이 있다면, 애플리케이션 계층 데이터는 B에서 A로 흐르는 동시에 A에서 B로 흐를 수 있음.
> 

TCP 연결은 항상 단일 송신자와 단일 수신자 사이의 `점대점(point-to-point)` 연결임. 따라서 단일 송신 동작으로 여러 수신자에게 데이터를 전송하는 '**멀티캐스팅(multicasting)**'은 TCP에서는 불가능함.

### TCP 연결 과정

- `클라이언트 프로세스(client process)` : 연결을 초기화하는 프로세스임.
- `서버 프로세스(server process)` : 요청을 기다림.

### 세 방향 핸드셰이크(three-way handshake)

*(3.5.6에서 더 자세히 다룰 예정임)*

1. 클라이언트 애플리케이션이 서버의 프로세스와 연결을 설정하기를 TCP에게 요청함.
2. 클라이언트의 트랜스포트 계층이 서버와의 연결 설정을 진행함. 클라이언트가 특별한 TCP 세그먼트를 먼저 보냄.
3. 서버는 `두 번째 특별한 세그먼트`로 응답함.
4. 클라이언트가 `세 번째 특별한 세그먼트`로 다시 응답함. 첫 두 세그먼트에는 `페이로드(payload)`가 없고, **세 번째 세그먼트는 페이로드를 포함할 수 있음.**

### TCP 연결이 설정된 이후

TCP 연결이 설정되면, 두 애플리케이션 프로세스는 데이터를 주고받을 수 있음.

1. 클라이언트 프로세스가 **데이터를 소켓(프로세스의 관문)으로 보냄.**
2. 데이터는 클라이언트의 TCP로 전달됨.
    1. TCP는 연결의 `송신 버퍼(send buffer)`로 데이터를 이동시킴.
    2. 송신 버퍼에서 데이터 묶음을 만들어 네트워크로 보냄. 전송 타이밍은 TCP가 정함.

---

### 최대 세그먼트 크기(maximum segment size, MSS)

> 세그먼트로 모아 담을 수 있는 데이터 양은 최대 세그먼트 크기(MSS)로 제한됨.
> 

MSS를 결정하는 주요 요소는 다음과 같음:

- 로컬 송신 호스트가 전송할 수 있는 링크 계층 프레임의 최대 크기 (`MTU`와 연관됨).
- TCP/IP 헤더를 포함한 데이터가 링크 계층 프레임에 딱 맞도록 제한됨.

> 💡 MSS는 TCP 세그먼트 헤더를 제외한 데이터의 최대 크기임.
> 

---

## 3.5.2 TCP 세그먼트 구조

### 구조

### **헤더 필드**

- `출발지와 목적지 포트 번호(source and destination port number)`
- `체크섬 필드(checksum field)`
- 32비트 `순서 번호 필드(sequence number field)`
- 32비트 `확인응답 번호 필드(acknowledgement number field)`
- 16비트 `수신 윈도(receive window)` : 흐름 제어에 사용됨.
    
    (수신자가 받아들이려는 바이트의 크기를 나타내는 데 사용됨)
    
- 4비트 `헤더 길이 필드(header length field)` : 32비트 워드 단위로 TCP 헤더의 길이를 나타냄.
- `옵션 필드(option field)`
    - 이 필드는 선택적이고 가변적인 길이를 가짐.
    - 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 이용됨.
- `플래그 필드(flag field)` : 6비트를 포함함.
    - `ACK` 비트 : 확인응답 필드에 있는 값이 유용함을 가리키는 데 사용됨.
    - `RST`, `SYN`, `FIN` 비트 : 연결 설정과 해제에 사용됨.
    - `PSH` 비트 : 이 비트가 설정되었다면 이것은 수신자가 데이터를 상위 계층에 즉시 전달해야 함을 가리킴.
    - `URG` 비트
        - 이 세그먼트에서 송신 측 상위 계층 개체가 ‘긴급’으로 표시하는 데이터임을 가리킴.
        - 이 긴급 데이터의 마지막 바이트의 위치는 16비트의 `긴급 데이터 포인터 필드(urgent data pointer field)`에 의해 가리켜짐.

### **데이터 필드**

애플리케이션 데이터의 일정량을 담음.

---

### MSS

MSS는 세그먼트 데이터 필드의 크기를 제한함.

- 큰 파일 전송 시, 일반적으로 MSS 크기로 파일을 분절함.
- 많은 대화식 애플리케이션은 MSS보다 작은 양의 데이터를 전송함.

---

## 순서 번호와 확인응답 번호

이 두 필드는 TCP의 신뢰적인 데이터 전송 서비스의 중대한 부분임.

### 순서 번호

> TCP는 데이터를 구조화되어 있지 않고 단지 순서대로 정렬되어 있는 바이트 스트림으로 봄.
> 

> 세그먼트에 대한 순서 번호는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호임.
> 

예를 들어:

- 데이터 스트림은 500,000 바이트로 구성된 파일이라고 가정함.
- MSS는 1,000 바이트.
- 데이터 스트림의 첫 번째 바이트는 0으로 설정함.

아래 그림처럼 TCP는 데이터 스트림으로부터 500개의 세그먼트들을 구성하며, 각 세그먼트가 할당받는 순서 번호는 다음과 같음.

> 💡 각각의 순서 번호는 적절한 TCP 세그먼트의 헤더 내부의 순서 번호 필드에 삽입됨.
> 

### 확인응답 번호

TCP는 **전이중 방식**임을 상기하자.

(호스트 A가 호스트 B로 데이터를 송신하는 **동안에** 호스트 B로부터 데이터를 수신하게 해줌)

호스트 B로부터 도착한 각 세그먼트는 B로부터 A로 들어온 데이터에 대한 `순서 번호`를 가짐.

> 💡 호스트 A가 자신의 세그먼트에 삽입하는 확인응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서 번호임.
> 

예를 들어:

호스트 A가 호스트 B로부터

`0 ~ 535의 바이트를 포함하는 어떤 세그먼트`와 `900 ~ 1,000의 바이트를 포함하는 또 다른 세그먼트`를 수신했다고 가정함.

*(어떤 이유 때문인지 몰라도, 호스트 A는 그 사이 `536~899의 바이트`를 아직 수신하지 않았음)*

호스트 A는 **B의 데이터 스트림을 재생성하기 위해** 536번째(와 그 다음의) 바이트를 아직 기다리고 있음.

그러므로 B에 대한 A의 다음 세그먼트이 `확인응답 번호 필드`에 536을 가질 것임.

> TCP는 스트림에서 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인응답하기 때문에,
> 
> 
> TCP는 `누적 확인응답(cumulative acknowledgment)`을 제공한다고 함.
> 

---

위 예에서 호스트 A는 `세 번째 세그먼트(900~1,000 값의 바이트)`를 `두 번째 세그먼트(536~899 값의 바이트)`가 수신되기 전에 수신함.

*즉, 세 번째 세그먼트는 순서가 틀리게 도착했음.*

이 상황에서 호스트는 어떻게 행동을 할까?

> TCP RFC는 TCP 연결에서 순서가 바뀐 세그먼트를 수신할 때 호스트가 어떤 행동을 취해야 하는지에 대한 어떤 규칙도 부여하지 않았고,
> 
> 
> TCP 구현 개발자에게 맡기고 있음.
> 

두 가지 선택지

1. 수신자가 순서가 바뀐 세그먼트를 **즉시 버림.**
2. 수신자는 순서가 바뀐 데이터를 보유하고, **빈 공간에 잃어버린 데이터를 채우기 위해 기다림.**

*후자가 네트워크 대역폭 관점에서는 효율적이며, 실제에서도 취하는 방법임.*

## 텔넷: 순서 번호와 응답확인 번호 사례연구

### 텔넷(Telnet)

- 원격 로그인을 위한 대표적인 애플리케이션 계층 프로토콜.
- TCP 상에서 작동하며 두 호스트 간의 통신을 지원함.

---

**호스트 A가 호스트 B로** 텔넷 세션을 시작한다고 가정.

- 호스트 A: 세션을 시작하는 `클라이언트`
- 호스트 B: 세션에 응답하는 `서버`

> 💡 세그먼트의 순서 번호 = 데이터 필드에서 첫 번째 바이트의 순서 번호
> 
- 클라이언트의 초기 순서 번호: `42` → 클라이언트가 송신하는 첫 번째 세그먼트는 **순서 번호 42**를 가짐.
- 서버의 초기 순서 번호: `79` → 서버가 송신하는 첫 번째 세그먼트는 **순서 번호 79**를 가짐.

> 💡 확인응답 번호 = 호스트가 다음으로 기대하는 데이터의 첫 번째 바이트 순서 번호
> 

TCP 연결이 초기화되고 **데이터가 송신되기 전**,

- 클라이언트는 바이트 `79`를 기다리고 있음.
- 서버는 바이트 `42`를 기다리고 있음.

---

사용자가 문자 ‘C’를 입력한 후, **3개의 세그먼트**가 송신된다고 가정. 이는 `세 방향 핸드셰이크(three-way handshake)`로 설명됨.

> 1️⃣ 첫 번째 세그먼트
> 
- 클라이언트에서 서버로 전송됨.
- `순서 번호 필드`에 `42`가 포함됨.

> 2️⃣ 두 번째 세그먼트
> 
- 서버에서 클라이언트로 전송됨.
- 두 가지 역할 수행:
    1. **데이터 확인응답 제공**
        - 확인응답 필드에 `43`을 설정함으로써,
            1. 서버는 클라이언트로부터 바이트 `42`를 성공적으로 수신했음을 알림.
            2. 앞으로 바이트 `43`을 기대함을 표시.
    2. **문자 ‘C’를 반향(echo)**
        - 데이터 필드에 문자 ‘C’의 ASCII 값을 포함.
        - 이 세그먼트는 TCP 연결의 서버-클라이언트 데이터 흐름에서 첫 번째 순서 번호인 `79`를 가짐.

> 💡 데이터 확인응답은 서버-클라이언트 간 데이터가 포함된 세그먼트 내에서 전송됨.
> 

= 확인응답은 **`피기백(piggyback)` 방식**으로 처리됨.

> 3️⃣ 세 번째 세그먼트
> 
- 클라이언트에서 서버로 전송됨.
- **목적:** 서버로부터 수신한 데이터에 대한 확인응답 수행.
    - **빈 데이터 필드**를 가짐.
    - 즉, 클라이언트-서버 데이터와 함께 **피기백되지 않음.**
- `확인응답 필드`에 `80`을 설정:
    - 클라이언트는 서버로부터 바이트 `79`를 포함한 데이터를 수신했으며,
    - 이제 바이트 `80`부터 시작하는 데이터를 기대하고 있음을 나타냄.

> 💡 세그먼트가 데이터를 포함하지 않더라도 TCP는 순서 번호 필드를 필수적으로 포함하기 때문에 순서 번호가 설정됨.
>
