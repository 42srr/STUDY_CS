## 3.5 연결지향형 트랜스포트: TCP

### 3.5.1 TCP 연결

- 전이중 서비스 제공
    - 양방향 동시 세그먼트 전송
    - MSS: 세그먼트의 데이터 필드 최대 크기(보통 1460 바이트)
    - 송신 버퍼에서 MSS 단위로 송신
- 항상 단일 송신자와 단일 수신자 사이의 점대점
    - 멀티캐스팅은 TCP 에서는 불가능
- 3-Way Handshake
    - 클라이언트와 서버 간에 동기를 맞추는 과정
    - 동기 정보: 소켓 주소, 시작 순서 번호, 수신 윈도우 크기
    - 주고 받는 세그먼트를 SYN 세그먼트라고 함
        - 클라이언트: SYN 세그먼트 전송
            - SYN 비트 1 설정
            - 시작 순서번호(ISN) 설정
            - ACK 를 위해 순서번호 1 소비(가상의 1바이트 데이터 전송)
        - 서버: SYN + ACK 세그먼트 전송
            - SYN 비트와 ACK 비트 1 설정
            - 시작 순서 번호(ISN) tㅓㄹ정
            - 확인번호(ACK) 설정
            - 수신 윈도우 크기 설정
            - ACK 를 위해 순서번호 1 소비(가상의 1바이트 데이터 전송)
            - 이후 DATA 세그먼트 전송
        - 클라이언트: ACK 세그먼트 전송
            - ACK 비트 1 설정
            - 수신 윈도우 크기 설정
            - 데이터 포함 가능
            - 데이터 미포함 시에는 순서 번호 소비 x
            - 이후 DATA 세그먼트 전송
- 서버 연결 소켓: 서버 IP 주소와 서버 Port 번호 공유가능

### TCP 연결방법

- 클라이언트 애플리케이션 프로세스가 서버 프로세스가 세 방향 핸드셰이크를 통해 TCP 연결 진행
- TCP 연결이 설정되면, 클라이언트 프로세스는 소켓을 통해 데이터 스트림 전달
- 데이터는 클라이언트에서 동작하고 있는 TCP 에 맡겨짐
- TCP 는 초기 세 방향 핸드셰이크 동안 준비된 버퍼 중의 하나인 연결의 송신 버퍼로 데이터를 보냄
- MSS
    - TCP 세그먼트와 TCP/IP 헤더 길이가 단일 링크 계층 프레임에 딱 맞도록 정해짐
    - 세그먼트에 있는 애플리케이션 계층 데이터에 대한 최대크기임
- TCP 세그먼트: TCP 헤더와 클라이언트 데이터를 하나로 짝지은 것
    - TCP 가 상대에게서 세그먼트를 수신했을 때, 세그먼트의 데이터는 TCP 연결의 수신 버퍼에 위치
    - 애플리케이션은 이 버퍼로부터 데이터의 스트림을 읽음
- TCP 연결은 한 쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결과 다른 쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결의 집합으로 이루어짐

### 3.5.2 TCP 세그먼트 구조
- 헤더필드와 데이터 필드로 구성
- 출발지와 목적지 포트 번호: 상위 계층 애플리케이션으로부터 다중화와 역다중화를 하는 데 사용
- 체크섬 필드
- 순서번호 필드, 확인 응답 번호 필드: 신뢰적인 데이터 전송 서비스 구현에서 TCP 송신자와 수신자에 의해 사용
- 수신 윈도 필드: 흐름제어
- 헤더 길이 필드: 32 비트 워드 단위로 TCP 헤더의 길이를 나타냄
- 옵션 필드: 송신자와 수신자가 MSS 협상, 고속 네트워크에서에서 사용하기 위한 윈도 확장 요소로 이용, 타임 스탬프 옵션 정의
- 플래그 필드
    - ACK
    - RST, SYN, FIN: 연결 설정과 해제에 사용
    - PSH: 수신자가 데이터 상위 계층에 즉시 전달해야하는지 가리킴
    - URG: 송신 측 상위 계층 개체가 긴급으로 표시하는 데이터
        - 긴급 데이터 포인터 필드에 의해 가리켜짐
        - TCP 는 긴급 데이터가 존재할 때 수신 측 상위 계층 개체에 통지, 긴급 데이터의 끝에 대한 포인터 전달

### 순서 번호와 확인 응답 번호

- 세그먼트에 대한 순서 번호: 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호
- 확인 응답번호: 호스트 A 가 자신의 세그먼트에 삽입하는 확인응답 번호는 호스트 A 가 호스트 B 로부터 기대하는 다음 바이트의 순서번호
    - TCP 는 스트림에서 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인응답하기 때문에, 누적 확인응답을 제공

### 텔넷: 순서번호와 응답확인 번호 사례연구

- 텔넷: 원격 로그인을 위해 사용되는 유명한 애플리케이션 계층 프로토콜
- TCP 상에서 실행되며, 한 쌍의 호스트들 사이에서 동작하도록 설계
- 에코 백(echo-back): 텔넷 사용자가 보는 문자가 이미 원격 사이트에 수신되고 처리되었음을 나타냄
    - 각 문자는 사용자가 키를 누르는 시간과 문자가 사용자의 모니터네 표시되는 시간 사이에서 네트워크를 두 번 횡단
- 서버가 클라이언트에게 보내는 확인응답은 서버-클라이언트 데이터 세그먼트 상에서 피기백된다 라고 말함

### 3.5.3 왕복 시간(RTT) 예측과 타임아웃

### 왕복 시간 예측

### RTT

- 세그먼트가 송신된 시간으로부터 그 세그먼트에 대한 긍정 응답이 도착한 시간까지의 시간 길이
- 네트워크 상태에 따라 가변적인 시간

### TCP 의 RTT 추정

$$
EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT
$$

- EstimatedRTT 의 새로운 값은 이전 EstimatedRTT 값과 SampleRTT 에 대한 새로운 값의 가중된 조합
- 권장되는 a 의 값은 a = 0.125
    - 기존 추정 RTT 를 87.5 % 반영, 새로 측정한 RTT 를 12.5 % 반영
- 지수적 가중 이동 평균
    - 주어진 SampleRTT 의 가중치가 갱신 절차가 진행됨에 따라 빠르게 지수적으로 감소
    - 최근 샘플들이 네트워크 상의 현재 혼잡을 더 반영 → 이 가중평균은 예전 샘플보다 최근 샘플에 높은 가중치를 줌

### TCP RTT 분산 추정

- 분산RTT: 추정 RTT 값과 실제 RTT 값의 차이

$$
(1 - B) * 분산RTT + B * |측정RTT - 추정RTT|
$$

- B = 0.25

### 재전송 타임아웃 주기의 설정과 관리

$$
TimeoutInterval = EstimatedRTT + 4 * DevRTT
$$

- 분산RTT * 4: 안전여분

### 3.5.4 신뢰적인 데이터 전송

### TCP 세그먼트 전송 규칙

- 누적 수신확인
    - 누적적으로 완전하게 수신된 바이트 스트림 번호 확인
- 중복 ACK 수신
    - 순서가 바뀐 세그먼트 도착
    - 중간 세그먼트 손실
- 단일 타이머
    - 누적 수신 확인이 되지 않은 가장 오래된 세그먼트에 대한 재전송 타이머 유지

### 재전송 기반 오류 복구

- Timeout 에 의한 재전송
    - 라우터 버퍼 오버플로우에 의한 세그먼트 손실
    - 네트워크 혼잡 상황에 따른 버퍼 오버플로우 발생
    - 충분히 긴 시간 동안 ACK 미수신

### 빠른 재전송

- 세그먼트가 손실된 상황에서 timeout 까지 불필요한 긴 시간 대기 회피
- 3개 중복 ACK 도착하면 timeout 과 무관하게 누적 수신 확인 다음 세그먼트 재전송
- 순서가 바뀐 세그먼트 도착
    - 1 ~ 2 개의 중복 ACK 후 정상 ACK 회신
    - 연속된 세그먼트의 도착 시간에 큰 차이가 없음
    - 3개 이상의 중복 ACK 가 발생하면 순서 문제가 아니라고 판단

### 3.5.5 흐름 제어

- 정의: 송신 TCP 가 지나치게 많은 데이터를 한꺼번에 송신함으로써 수신 TCP 의 버퍼가 넘쳐 데이터 손실이 발생하는 문제를 방지하는 매커니즘
- 방안: 수신 TCP 는 자신의 수신 버퍼 내의 여유 공간의 크기를 송신 TCP 에게 통지하고, 송신 TCP 는 통지된 여유 공간의 크기보다 적은 양의 데이터를 송신
- 수신윈도우: 수신 버퍼 내의 여유 공간의 크기
    - 연결 설정 시에 수신 버퍼 크기와 동일하게 설정
    - 수신데이터의 버퍼 저장과 응용 프로세스에 의한 버퍼 데이터 읽기 과정에서 수신윈도우 변화
    - 수신 TCP 가 송신 TCP 로 전달하는 세그먼트의 수신윈도우 필드에 포함되어 통보
    - 수신 윈도우 = 0
        - 송신 TCP는 더 이상 데이터를 전송하지 않고 수신 TCP 로부터 변경된 수신윈도우가 도착하기를 기다림
        - 수신 TCP 는 송신 TCP 로 전송할 확인 세그먼트가 없어 수신윈도우 변화를 통보하지 못함
        
        → Deadlock 상태 진입
        
    - 윈도우 프로브 세그먼트
        - 수신윈도우가 0 일때 송신 TCP 가 수신 TCP 에게 주기적으로 전송하는 1바이트 세그먼트
        - 수신 TCP 는 프로브 세그먼트에 대한 ACK 세그먼트를 통해 최신 수신윈도우 정보를 송신 TCP 에게 제공

### 송신 TCP 의 흐름제어

- 마지막으로 송신한 바이트 번호와 확인 세그먼트를 통해 마지막으로 수신 확인된 바이트 번호의 차이가 항상 수신윈도우보다 작게 유지
- 마지막 송신 바이트 번호 - 마지막 수신확인 바이트 번호 ≤ 수신윈도우

### 3.5.6 TCP 연결 관리

1. 클라이언트 측 TCP 는 서버 TCP 에게 특별한 TCP 세그먼트 송신
2. TCP 세그먼트를 포함하는 IP 데이터그램이 서버 호스트에 도착하면, 서버는 데이터그램으로부터 TCP SYN 세그먼트 추출
3. 연결 승인 세그먼트를 수신하면, 클라이언트는 연결에 버퍼와 변수를 할당한 후 클라이언트 호스트는 서버로 또 다른 세그먼트 송신
- TCP 연결에 참여하는 두 프로세스 중 하나가 FIN 비트를 1로 설정함으로써 연결을 끝낼 수 있음
    - 연결이 끝날 때, 호스트의 자원은 회수됨

### TCP 상태

`CLOSED` → SYN 세그먼트를 송신한 뒤 `SYN_SENT` → 확인 응답 수신하면 `ESTABLISHED` → `FIN_WAIT`: FIN 전송하고, 클라이언트 애플리케이션이 연결 종료 시작 → `FIN_WAIT_2` : ACK, 추가 전송 없음 → FIN 수신, ACK 송신한 후 `TIME_WAIT` → 30초간 대기 → `CLOSED`

## 3.6 혼잡 제어의 원리

### 3.6.1 혼잡의 원인과 비용

### 시나리오1: 2 개의 송신자와 무한 버퍼를 갖는 하나의 라우터

- 호스트 A 와 B 는 각각 1MB/s 로 데이터를 전송하지만, 공유 링크 용량 R 로 인해 각 호스트의 최대 처리량은 R / 2 를 초과할 수 없음
- 전송률이 R / 2 를 초과하면 라우터의 큐 크기가 무한히 증가하여 평균 지연 시간이 무제한으로 커짐
- 링크 용량 근처에서 동작하면 처리량은 최적이지만 지연이 급격히 증가하는 문제 발생

### 시나리오2: 2개의 송신자, 유한 버퍼를 가진 하나의 라우터

- 패킷이 손실되면 송신자는 이를 재전송해야 하며, 이로 인해 추가적인 네트워크 부하가 발생
- 너무 빠른 타임 아웃으로 인해 손실되지 않은 패킷까지 재전송되면, 불필요한 데이터가 라우터를 거쳐 네트워크 성능이 저하됨
- 재전송된 패킷이 중복 전달되면서 링크 대역폭을 낭비하고, 전체적인 처리량을 감소키는 문제 발생

### 시나리오3: 4개의 송신자와 유한 버퍼를 갖는 라우터, 그리고 멀티홉 경로

- 여러 호스트가 동일한 라우터를 공유하면 혼잡이 증가하고, 네트워크 성능이 저하될 수 있음
- 라우터는 송신자에게 직접 초크 패킷을 보내거나, 패킷 내 특정 필드를 수정하여 간접적으로 혼잡을 알릴 수 있음
- 간접적인 혼잡 알림은 왕복 시간이 필요하므로, 송신자가 혼잡을 인지하고 조치하기까지 지연이 발생할 수 있음

## 3.7 혼잡제어

### 3.7.1 전통적인 TCP 혼잡 제어

### 네트워크 혼잡

: 트래픽 증가로 인해 라우터/스위치 버퍼의 큐잉 지연시간 증가 및 오버플로우 발생

- 심각한 혼잡: timeout 발생
- 경미한 혼잡: 중복 ACK 발생(3 duplicate ACKs)

> 혼잡윈도우: ACK 없이 보낼 수 있는 데이터 세그먼트의 양
> 

### TCP 의 혼잡 제어 원리

- 세그먼트 전송률 축소 조정

### 흐름 제어를 위한 TCP 전송률 제어

- 마지막송신바이트번호 - 마지막수신확인바이트번호 ≤ 수신윈도우

### 혼잡제어를 위한 TCP 전송률 제어

- 마지막송신바이트번호 - 마지막수신확인 바이트번호 ≤ min(수신윈도우, 혼잡윈도우)
1. 슬로스타트
    - 연결 시작 또는 혼잡 발생 시에 혼잡윈도우를 최솟값부터 전송률을 낮게 시작
    - ACK 가 수신될때마다 혼잡윈도우를 1씩 증가
    - RTT 마다 혼잡윈도우를 2배씩 증가
2. 혼잡회피
    - 슬로우 스타트 구간에서 혼잡 윈도우는 지수적으로 증가
    - 혼잡 윈도우가 임계치에 도달하거나 넘어가면 선형적으로 증가하도록 증가 속도를 조정하는 알고리즘
    - RTT 마다 혼잡윈도우를 1씩 증가
    - ACK 가 수신될 때마다 혼잡위도우를 1씩 증가
3. 빠른 복구
    - 3개의 중복 ACK 에 의한 빠른 재전송 시에 적용: 경미한 혼잡 상황
    - 정상 ACK 가 수신되어 오류 복구가 완료되면 슬로우 스타트 구간을 건너뛰고 혼잡 회피 단계로 진입
    
    ### 알고리즘
    
    1. 임계치를 현재 혼잡 윈도우의 1/2 로 설정
    2. 손실된 세그먼트 재전송
    3. 혼잡 윈도우를 임계치 + 3 으로 설정
    4. 여전히 중복 ACK 를 수신하면 cwnd = cwnd + 1, 새로운 세그먼트 추가 전송 가능
    5. 정상 ACK 를 수신하면 cwnd = ssthresh, 혼잡 회피 단계로 진입

### TCP 큐빅

- 혼잡 윈도를 세제곱 함수로 빠르게 증가시켜, 손실 전 전송 속도(Wmax)에 빨리 도달 후 신중하게 대역폭 탐지.
- 혼잡 윈도 증가가 K 값에 따라 조정됨.
- K 값이 클수록 빠르게 새로운 전송 속도를 찾음.
- 차이점: TCP 큐빅은 TCP 리노보다 더 빠르고 효율적으로 전송 속도를 증가시킴.
- 사용 현황: 리눅스의 기본 TCP 버전, 인기 있는 웹 서버의 50%가 TCP 큐빅 사용.

### TCP 리노 처리율 분석

: 타임아웃 후 슬로 스타트 단계를 무시하고, 안정 상태에서의 평균 처리율을 고려.

- 전송률: 혼잡 윈도(W)와 RTT에 따라 결정됨. 전송률은 W/RTT에서 W/(2•RTT) 사이로 변동.
동작 과정:
- TCP는 왕복 시간(RTT)당 MSS만큼 윈도를 증가시켜 대역폭을 확보.
- 패킷 손실 발생 시 윈도가 반으로 감소하고, 이후 다시 W/RTT까지 증가.
- 평균 처리율: TCP 연결의 평균 처리율은 약 0.75 * W / RTT로 계산됨.
- 이론적 모델: 안정 상태에서의 TCP 동작을 기반으로 대역폭과 손실률을 연계하는 식을 유도.

### 3.7.2 네트워크 지원 명시적 혼잡 알림과 지연 기반 혼잡 제어

- **ECN(명시적 혼잡 알림)**
    - 네트워크 혼잡을 **미리 감지**해서 패킷 손실 없이 송신자에게 알림.
    - 송신자는 혼잡 신호를 받으면 윈도 크기를 줄여 조절함.
- **지연 기반 혼잡 제어 (TCP Vegas)**
    - 패킷 손실 대신 **RTT(왕복 지연) 증가**를 감지해 속도 조절.
    - 지나치게 큐가 쌓이지 않도록 **최적의 속도 유지**가 목표.
- **TCP 공평성 & 병목 링크 공유**
    - TCP는 **AIMD 알고리즘**으로 공평하게 대역폭을 나눔.
    - RTT가 짧은 연결이 더 유리할 수도 있음.
    - UDP는 혼잡 제어 없이 **TCP보다 더 많은 대역폭을 차지**할 수 있음.

## 2.8 트랜스포트 계층 기능의 발전

QUICK: 빠른 UDP 인터넷 연결

- 기존의 TCP보다 더 빠르고 효율적인 연결을 제공
- 연결지향적이고 안전함: 핸드셰이크를 통한 TCP 연결 후 TLS 를 설정하여 여러 RTT 가 필요항 프로토콜 스택보가 더 빠른 설정 제공
- 스트림: 여러 애플리케이션 레벨의 스트림들을 다중화할 수 있음, 새 스트림 빠르게 추가 가능
- 신뢰적이고 TCP 친화적인 혼잡 제어 데이터 전송