# Transprot Layer Basic

## TCP/IP Protocol Model

- 트랜스포트 레이어이다.
- 애플리케이션 사이의 데이터를 운반한다.

## Typical Communication Path

- 라우터는 L3레벨로 네트워크 계층까지밖에 존재하지 않는다
- 트랜스포트 계층부터는 센더와 리시버 양 끝 호스트에 위치한다.

## Transport Services And Protocols

- 트랜스포트 계층은 프로세스 간의 논리적 통신을 제공한다.
- 여기서의 단위를 세그먼트, 또는 패킷이라고 부른다.
- 송신쪽에서는 앱 메시지를 세그먼트로 쪼개서 헤드를 붙여서 네트워크 계층으로 보낸다
- 수신쪽에서는 네트워 레이어에서 온 것을 다시 합쳐서 어플리케이션 계층으로 보낸다.

## Internet Transport-layer Protocols

- 신뢰적이고 순서를 지키는 경우 (TCP)
  - Congestion control
  - Flow control
  - Connection setup
  - 이거는 다음주에!
- 비신뢰적이고 순서를 지키지 않는 경우 (UDP)
- 이 프로토콜들은 아래를 보장해주지 않는다
  - delay guarantess -> 속도 보장
  - bandwidth guarantees -> 대역폭 보장

## Transport vs Network layer

### Network layer

- 호스트 간의 논리적 통신

### Transport layer

- 프로세스 간의 논리적 통신

## Addressing Processes

- 메시지를 받기 위해서는 프로세스들은 id를 가지고 있어야 한다.
- 호스트 장치들은 32비트의 IP 주소를 갖고 있다.
- IP(Internet Protocol)는 추후 배우겠지만 네트워크 계층 프로토콜이다.
- 여기서 알아야 하는 부분은 각 호스트가 적어도 하나의 IP 주소를 갖고 있다는 부분만 기억하자.
- 그리고 IP 주소와 더불어 포트 넘버 역시 알고 있어야 한다.

## Sockets

- 소켓을 통해 네트워크에서 프로세스로 데이터를 전달하고 또한 프로세스로부터 네트워크로 데이터를 전달하는 출입구 역할을 한다.
- 수신 측에 하나 이상의 소켓이 있을 수 있다.
- 각각의 소켓은 하나의 유일한 식별자를 갖는다.
- 이 식별자의 포맷은 TCP소켓인지 UDP 소켓인지에 따라 달라진다.

## Multiplexing and Demultiplexing

- 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 Demultiplexing (역다중화)라고 한다.
- 헤더 정보를 통해 정확한 소켓으로 세그먼트를 보내주는 것을 역다중화
- 출발지 호스트에서 소켓으로부터 데이터ㄹ 모으고 이에 대해 세그먼트 생성하기 위 각 데이터에 헤더 정보로 캡슐화하고 이 세그먼트들을 네트워크 계층으로 전달하는 작업을 Multiplexing(다중화)라고 한다.
- 여러 소켓으로부터 온 데이터들을 트랜스포트 헤더를 붙이고 관리하는 것을 다중화라고 한다.

## How Demultiplexing Works

- 소켓은 유일한 식별자 즉 포트 번호를 갖는다
- 각 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 특별한 필드를 갖는다.
- 이 필드는 출발지 포트 번호와 목적지 포트 번호 필드다.
- 호스트는 IP주소와 포트 넘버를 통해 적절한 소켓으로 세그먼트를 보낸다.
- 세그먼트가 호스트에 도착하면 트랜스포트 계층은 세먼트 안의 목적지 포트 번호를 검사하고 상응하는 소켓으로 세그먼트를 보낸다.

## Connectionless Demultiplexing

- UDP
- UDP 소켓이 목적지 IP 주소와 목적지 포트 번호로 구성된 두 요소로 된 집합에 의해 식별된다.
- 2개의 UDP 세그먼트가 출발지 IP주소와 출발지 포트 번호가 모두 다르거나 두 개 중 어느 하나가 다를지라도, **같은 목적지 IP 주소와 목적지 포트 번호를 가지면 2개의 세그먼트는 같은 목적지 소켓을 통해 같은 프로세스로 향할 것**이다.

## Connection-oriented demux

- TCP 소켓은 4개의 튜플로 구분된다
  - 출발지 IP 주소
  - 출발지 포트 번호
  - 목적지 IP 주소
  - 목적지 포트 번호
- UDP와 달리 다른 출발지 주소 또는 다른 출발지 포트 번호를 가지고 도착하는 2개의 TCP 세그먼트는 2개의 다른 소켓으로 향한다.
- 서버 호스트는 동시에 존재하는 많은 TCP 소켓을 지원할 수 있다.
- 웹 서버ㄹ은 각각의 연결된 클라이언트 관해 다른 소켓들을 가지고 있다.

## UDP : User Datagram Protocol

- UDP는 다중화/역다중화 기능과 간단한 오류 검사 기능을 제외하면 IP에 아무것도 추가하지 않는다.
- UDP 세그먼트들은
  - lost 잃어버리거나
  - delivered out-of-order to app 순서에 맞지 않게 배달될 수 있다.
- Connectionless
  - UDP는 sender 와 receiver에 핸드셰이킹이 없다.
  - 즉 연결설정이 없다.

## UDP : Segment header

- UDP 헤더는 2바이트씩 구성된 단 4개의 필드만을 갖는다.
- 체크섬은 세먼트 오류가 발생했는지를 검사하기 위해 수신 호스트가 사용한다.
- whe is there a UDP?
  - 혼잡 제어를 할 필요가 없다
  - 작은 헤더 사이즈
  - 단순하다
  - 딜레이를 발생시킬 수 있는 연결 설정을 할 필요가 없다.

## UDP checksum

- 목표 : 전송된 세그먼트에 에러를 탐색하기 위함이다.
- 체크섬은 세그먼트가 출발지로부터 목적지로 이동했을 때 UDP 세그먼트 안의 비트에 대한 변경사항이 있는지 검사하는 것이다.
- 송신자 측에서 UDP는 세그먼트 안에 있는 모든 16비트 워드의 합산에 대해 다시 1의 보수를 수행하며, 합산 과정에서 발생하는 오버플로는 윤회식 자리 올림을 한다.
- 이 결괏값이 UDP 세그먼트의 체크섬 필드 삽입된다.
- UDP는 오류 검사를 제공하지만, 오류를 회복하기 위한 어떤 일도 하지 않는다.
- 일부 UDP 구현에서는 손상된 세그먼트를 그냥 버리기도 하고 다른 구현에서는 경고와 함께 손상된 세그먼트를 애플리케이션에게 넘겨주기도 한다.

# Principles of Reliable Data Transfer

## Principles of Reliable Data Transfer

- channel : data가 송수신되는 논리적인 경로라고 생각
- 서스는 신뢰적으로 제공되어 보이지만 아래 계층에서 비신뢰적인 채널을 실제로 가지고 있다.
- 여기 논의하는 과정에서 채택할 한 가지 가정은 보내진 패킷은 일부 손실될 수도 있겠지만 보내진 순서대로 전달되는 것이다.
- 즉 하부채널은 패킷의 순서를 바꾸지 않는다.
- 이제부터 프로토콜 데이터 단위에 대해 '세그먼트' 보다 '패킷'이라는 용어를 사용한다.

## rdt1.0 : Reliable Transfer over Reliable Channel

- 현실에서는 존재하지 않지만 환경 자체가 reliable하다고 가정
- 즉 비트에러와 패킷 로스 둘 다 일어나지 않음
- 이 경우 transport layer는 할 일이 크게 없다.
- 자기 자신을 가리키는 화살표는 계속 이 일만 해라라는 것을 말함.

## rdt2.0 : Channel With Bits Errors (no loss!)

- 비트 오류가 있는 채널상에서의 신뢰적 데이터 전송
- bit error 여부 판단
- 이를 위해 체크섬을 사용한다. (헤드에 체크섬 필드 추가한다.)
- 체크섬 사용은 어디까지나 dest까지
- 그러면 sender는?
  - dest가 피드백을 해준다
  - ACK와 NAK
  - 그리고 이 피드백을 통해 재전송해준다.
- 이렇게 피드백을 받고 다시 보줘야 하므로 Stop-and-wait protocol을 사용한다.
- 만약 ACK와 NAK에서 에러가 발생한다면?
  - 중복 패킷을 보냄으로써 해결한다.
  - 중복 패킷은 어떻게 해결해야 할까?
    - 중복패킷의 경우 버린다.

## rdt2.1 : Introducing Sequence Number

- 순서번호 즉 시퀀스 넘버를 삽입하는 방식
- 센더는 같은 시퀀스 넘버를 다시 보내면 된다.
- 그리고 중복 패킷은 버리면 된다.
- 시퀀스 넘버가 길어질수록 헤더가 커짐 이는 오버헤드의 염려성
- 그러나 1bit만 있으면 됨
  - stop & wait 이므로 1비트만 있으면 됨
  - 이는 RDT only

## rdt2.2 : NAK-free Version

- NAK이 없는 신뢰적인 데이터 전송 프로토콜
- 효율성 개선
- 리시버는 ACK 세그먼트 헤드에 마지막 수신된 순서 번호 포함한다.
  - 0 -> 1 -> 0 -> 1

## rdt 3.0: Lossy Channel With Bit Error

- 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송
- 앞에 부분들로는 충분하지 않다.
- 패킷 로스의 경우 리시버 입장에서는 받았는지 모르기 때문에 ACK와 NAK가 오지 않기 때문
- 우리는 이를 위해 타이머를 넣기로 했다.
- 만약 시간안에 ACK가 오지 않으면 송신 측은 다시 한 번 패킷을 보낸다.

## rdt 3.0 in Action

- p194 그림 3.16 참고
- 조급한 타임아웃의 경우 순서가 꼬이겠지만 중복된 패킷에 대한 처리방안이 있으므로 괜찮다.

## Go-Back-N and Selective Repeat

### Performance of rdt3.0 (stop-and-wait)

- RTT (Round Trip Time) : 두 종단 시스템 사이의 광속 왕복 전파 지연
- 전송 후 대기 방식은 많은 시간을 기다려야 한다.
- 하지만 파이프라이닝을 통해 시간을 효율적으로 개선할 수 있다.

### Pipelined Protocols Operation

- 파이프라이닝 : 센더는 여러개의 "in-flight" 아직 인식되지 않은 여러 개의 패킷을 허용해야한다.
- 즉 파이프라이닝은 확인응답을 기다리지 않고 여러 패킷을 전송하도록 허용하는 것
- 이를 위해서 지켜야할 규칙
  - 순서 번호의 범위가 커져야 한다.
  - 프로토콜의 송신 측과 수신 측은 패킷 하나 이상을 버퍼링 해야한다. 즉 최소한 송신자는 전송되었으나 확인 응답되지 않은 패킷을 버퍼링 해야한다.
- 이를 통해 효율성을 개선할 수 있다.

## Go-Back-N : Sender & Receiver

- 송신자는 확인응답을 기다리지 않고 여러 패킷을 전송할 수 있다.
- window : ACK 없이 한 번에 보낼 수 있는 양, inflight-packet 포함 가능크기
- 프로토콜이 동작할 때 이 윈도는 순서 번호 공간에서 오른쪽으로 이동된다.
- 이런 이유로 GBN을 슬라이딩 윈도 프로토콜이라고 부른다.
- sliding window이기 때문에 중간에 패킷 loss가 나면 윈도우는 움직이지 않는다.
- 즉 ACK sequence number는 sequence number까지 모든 패킷을 잘 받았다는 것을 의미한다.
- GBN은 타임아웃 이벤트에 반응해야한다.
  - 만약 타임아웃이 발생한다면 송신자는 이전에 전송되었지만 아직 확인 응답되지 않은 모든 패킷을 다시 송신한다.
  - 가장 오래된 기준으로 타이머를 맞춘다
  - 타임아웃이 될 경우 window에 있는 모든 애들을 재전송한다.
- GBN은 프로토콜에서 수신자는 순서가 잘못된 패킷들을 버린다. 이는 구현하기 나름이긴하다.

## Selective Repeat

- Receiver은 올바르게 수신된 모든 패킷을 개별적으로 확인한다.
- 이를 위해 Receiver는 무조건 버퍼링이 필요하다
- Sender은 확인되지 않은(ACK되지 않은) 패킷들에 대해 개별적으로 시간 초과/재전송합니다
- 수신자에서 오류가 발생한 패킷을 수신했다고 의심되는 패킷만을 송신자가 다시 전송하므로 불필요한 재전송을 피한다.

## Selective Repeat : A Dilemma!

- 너무 큰 윈도를 가진 SR 수신자의 고민 : 새 패킷인가 아니면 재전송된 것인가?
- 이러한 문제를 해결하기 위해 sequence number는 window size의 2배 이상을 가져야 한다. 그러면 이 패킷이 새 패킷인지 재전송된 것인지 알아차릴 수 있다.
