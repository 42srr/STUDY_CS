# 3 트랜스포트 계층

## 3.1 트랜스포트 계층 서비스 및 개요

- 트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 애플리케이션 프로세스간의 논리적 통신을 제공
- 논리적 통신은 애필리케이션의 관점에서 프로세스들이 동작하는 호스트들이 직접 연결된 것처럼 보임.
- 호스트는 수많은 라우터와 다양한 형태의 링크를 통해 연결되어 지구상 다른 지역에 있을 수 있음.
- 애플리케이션 프로세스는 메시지 운반에 사용되는 물리적 인프라스트럭쳐의 세부 사항 상관없이 서로 메시지 송신 위해 트랜스포트 계층에서 제공하는 논리적 통신 사용.
- 트랜스포트 계층 세그먼트 : 송신 측의 트랜스포트 계층은 송신 애플리케이션 프로세스로부터 수신한 메시지

## 3.1.1 트랜스포트 계층과 네트워크 계층 사이의 관계

- 트랜스포트 계층은 프로토콜 스택에서 네트워크 계층 바로 상위에 존재.
- 트랜스포트 계층 프로토콜은 다른 호스트에서 동작하는 프로세스들 사이 논리적 통신 제공
- 네트워크 계층 프로토콜은 호스트들 사이의 논리적 통신 제공.

## 3.1.2 인터넷 트랜프소트의 계층의 개요

- UDP -> 비신뢰적이고 비연결형인 서비스를 요청한 애플리케이션 제공.
- TCP -> 신뢰적이고 연결지향형 서비스를 요청한 애플리케이션에 제공.
- 애플리케이션 설계 시, TCP와 UDP중 하나를 선택.
- 인터넷의 네트워크 계층 프로코콜 -> 인터넷 프로토콜(IP)
- IP 서비스 모델은 호스트들 간에 논리적 통신 제공 -> 최선형 전달 서비스
  IP 통신하는 호스틀간의 세그먼트를 전달하기 위해 최대한 노력하지만, 어떤 보장 하지 않음.
  IP는 세그먼트 내부 데이터의 무결성을 보장하지 않음
  IP는 비신뢰적인 서비스
- 각 호스트는 적어도 하나의 IP 주소를 갖는다.

### UDP와 TCP 서비스 모델

- UDP와 TCP의 가장 기본적인 기능은 종단 시스템 사이의 IP 전달 시버시를 정단 시스셈에 동작하는 두 프로세사 간의 전달 서비스로 확장.

* 트랜스포트 계층 다중화와 역다중화 : 호스트 대 호스트 전달, 프로세스 대 프로세스 전달
* UDP와 TCP는 헤더에 오류 검출 필드 포함해 무결성 검사 제공
* UDP 제공하는 서비스 두 가지
  1.  하나의 프로세스에 의해 전송된 데이터가 손상되지 않음
  2.  목적지 프로세스에 도착하는 것을 보장하지 않음.
* TCP 제공하는 서비스
  1.  신뢰적인 데이터 전송 제공
  2.  TCP 혼잡 제어 제공 (TCP는 네트워크에 보낼 트래픽 조절, UDP는 조절 안됨)

## 3.2 다중화와 역다중화

- 네트워크 계층이 제공하는 호스트 대 호스트 전달 서비스에서 호스트에서 동착하는 애플리케이션에 대한 프로세스 대 ㅍ로세스 전달 서비스로 확장을 살펴봄.

* 목적지 호스트에서의 트랜스포트 계층은 바로 아래의 네트워크 게층으로부터 세그먼트를 수신.
* 트랜스포트 계층은 호스트에서 동작하는 해당 애플리케이션 프로스세에게 세그먼트의 데이터를 전달하는 의무 진다.
* 역다중화 : 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업
* 다중화 : 출발지 호스트에서 소켓으로부터 데이터 모으고, 세그먼트를 생성하기 위해 각 데이터에 헤더 정보를 캡슐화, 그 세그먼트를 네트워크로 전달하난 작업.
* 트랜스포트 계층 다중화 두 가지 요구사항
  1.  소켓은 유일한 식별자를 갖는다
  2.  각 세그먼트는 세그먼트가 전달될 적절한 소켃을 가리키는 특별한 필드를 갖는다.
      - 출발지 포트 번호 필드, 목적지 포트 번호 필드
        (각 번호는 0~ 65535 16비트 정수)
        (0 ~ 1023 : 잘 알려진 포트 번호 -> 사용을 엄격히 제한)

### 비연결형과 다중화와 역다중화

- clinetSocket = socket(AF_INEF, SOCK_DGRAM)

- UDP 소켓 생성 시, 트랜스포트 계층은 포트 번호를 소켓에게 자동 할당.
- 1024 ~ 65535 사이의 포드 번호 할당

- clinetSocket.bind(('', 19157))

- bind를 이용해 특정 포트 번호 할당.
- 애플리케이션 개발자가 '잘 알려진 프로토콜' 서버 구현 시, 상응하는 잘 알려진 포트 번호 할당해야함.

### 연결지행형 다중화와 역다중화

- TCP 서버 에플리키이션은 '환영 소켓' 갖고 있음.
- TCP 클라이언트 다음 명령어로 소켓 생성, 연결 설정 및 요청 세그먼트 보냄.

- clientSocket = socket(AF_INET, SOCK_STREAM)
- clientSocket.connect((serverName, 12000))

- 목적지 12000 포트와 TCP 헤더 설정된 특별한 연결 설징 비트를 가진 TCP
- 세그먼트 12000 번호로 연결 수락을 가디라는 서버 프로세스 보냄.

- connectionSocket, addr = serverSocket.accept()

1. 세그먼트 안의 출발지 포트번호
2. 출발지 호스트의 IP 주소
3. 세그먼트 안의 목적지 포트 번호
4. 목적지 IP 주소

- 연결 요청 세그먼트는 네 가지 값에 의해 식별됨.

### 웹 서버와 TCP

- 클라이언트와 서버가 지속적인 HTTP 사용 시, 지속적인 연결의 존속 기간에 클라이언트와 서버는 서버 소켓을 통해 HTTP 메시지 교환
- 비지속적인 HTTP 사용 시, 모든 요청 / 응답마다 새로운 TCP 연결 생성되고 종료 됨. -> 비번한 소켓 생성 종료는 웹 서브 성능 부담을 줌.

## 3.3 비연결형 트랜스포트 UDP

- 애플리케이션에 UDP가 적합한 이유

1. 무슨 데이터를 언제 보낼지에 대해 애플리케이션 레벨에서 더 정교한 제어
2. 연결 설정이 없음
3. 연결 상태가 없음
4. 작은 패킷 헤더 오버헤드

## 3.3.1 UDP 세그먼트 구조

- UDP 데이터그램의 데이터 필드 위치.
- UDP 헤더는 2바이트씩 구성된 단 4개의 필드만 작음
- 체크섬 : 세그먼트 오류가 발생했닌지를 검사하기 위해 수신 호스트 사용

## 3.3.2 UDP 체크섬

- UDP 체크섬은 오류 검출 하기 위함.
- 세그먼트가 출발지로부터 목적지로 이동했을 때, UDP 세그먼트 안의 비트에 대한 변경 사항아 있는지 검사함.
- 송신자 측은 UDP는 세그먼트 안에 있는 모든 16비트 워드의 합산에 다시 1의 보수를 수행해 합산 과정에서 발생하는 오버플로 - 윤회식 자리올림.

* 많은 링크 계층 프로토콜이 오류 검사 제공하는데 왜 UDP가 체크섬을 제공하는지.
  1.  출발지와 목적지 사이의 모든 링크가 오류 검사 제공하는 것을 보장할 수 없음
  2.  즉, 링크 중에서 하나가 오류 검사를 제공하지 않은 프로토콜 사용할 수 있음.
  3.  세그먼트들이 정확하게 링크를 통해 전송되었을지라도, 세그먼트가 라우터의 메모리에 저장될 때 비트 오류가 발생할 수 있음.

## 3.4 신뢰적인 데이터 전송의 원리

- 신뢰적인 데이터 전송 구현 문제는 링크 계층와 애플리케이션에도 발생.
- 서비스 추상화 구현하는 것이 신뢰적인 데이터 전송 프로토콜의 의무임. -> 신뢰적인 전송 프로토콜의 '아래에 있는' 계층이 신뢰적이지 않을 수 있어서 어려워짐.
- 단반향 데이터 전송의 경우 송신 측으로부터 수신측 까지의 데이터 전송만 고려.

* 양뱡향 데이터 전송 : 송신 측과 수신 측은 전송 데이터를 포함하는 패킷을 교환하는 것 외에 패킷을 양쪽으로 전송해야함.

## 3.4.1 신뢰적인 데이터 전송 프로토콜의 구축

### 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송 : rdt1.0

### 비트 오류가 있는 채널상의 신뢰적인 데이터 전송 : rdt2.0

- 긍정 확인응답, 부정확인응답
- 자동 재전송 요구 프로토콜

* 비트 오류를 처리하기 위한 세 가지 부가 프로토콜 기능
  1.  오류 검출
      비트 오류가 발생 했을 때 수신자가 검출할 수 있는 기능 필요.
      인터넷 체크섬 필드 사용
      수신자가 패킷 비트 오류를 검출하고 복구
  2.  수신사 피드백
      송신자가 수신자의 상태를 알기 위한 유일한 방법은 수신자가 송신자에게 피드백 제공
  3.  재전송

### 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송 : rdt3.0

- 송신자는 데이터 패킷이 손실되었는지 ACK 손실인지 ACK가 단순히 지나치게 지연된 건지 알지 못함.
- 주어진 시간이 지난 후 송신자를 인터럽트 할수 있는 카운트타이머가 필요.
  1.  매 패킷이 송신된 시간에 타이머를 시작
  2.  타이머 인터럽트 반응
  3.  타이머를 멈춤

## 3.4.2 파이프라이닝된 신뢰적인 데이터 전송 프로토콜

- 프로토콜 rdt3.0은 기능적으로 정확한 프로토콜
- rdt3.0의 핵심적인 성능 문제는 전송 후 대기 프로토콜
- 해결책 -> 전송 후 대기 방식으로 동작하는 대신 송신자에게 확인응답을 기다리지 않고 여러 패킷을 전송하도록 허용.
- 많은 전송 중인 송신자-수신자 패킷을 파이프라인에 채워 넣어 나태날 . 수있음
- 해당 기술 이름을 파이프라이닝아라고 함.
  1.  순서 번호의 범위가 커져야함 -> 전송 중인 패킷은 유일한 순서 번호를 가져야함
  2.  프로토콜의 송신 측과 수신 측은 패킷 하나 이상을 버퍼링해야함.
  3.  필요한 순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜 손실 패킷과 손상 패킷 상당히 지연된 패킷에 대해 응답하는 방식에 달려있음.

## 3.4.3 GBN

- 프로토콜에서 송신자는 확인 응답을 가다리지 않고 여러 패킷을 전송 할 수 있음.
- 파이프라인에서 확인응답이 안 된 패킷의 최대 허용수 n보타 크지 말아야함.
- GBN 프로토콜은 슬라이딩 윈도 프로토콜이라고 부른다.
- GBN 송신자는 다음과 같은 세 가지 타입의 이벤트에 반응해야함.
  1.  상위로부터의 호출
      송신자가 윈도가 가득 찼는지, 확인응답되지 않는 패킷이 있는지 확인
  2.  ACK 수신
      GBN프로코톨 순서 번호를 n 가진 패킷에 대한 확인 응답은 누적 확인응답으로 인식
  3.  타임아웃 이벤트

### 3.4.4 SR

- SR 프로토콜은 수신자에서 오류가 발생한 패킷을 수신했다고 의심되는 패킷만을 송신자가 다시 전송하므로 불필요한 재전송 피함.

* 필요에 따라 각각의 개별적인 재전송은 수신자가 올바르게 수신된 패킷에 대한 개별적인 확인응답을 요구
