## 3.1~3.3절

### **R1**

> 간단한 송신 프로토콜의 절차를 설명할 수 있는가?
> 

a) Simple Transport Protocol의 송신 절차

1. 송신측 STP:
    - 최대 1196바이트의 데이터 청크 (헤더가 4바이트이므로)
    - 목적지 호스트 주소 (IP 주소)
    - 목적지 포트 번호
2. STP는 4바이트 헤더를 데이터 청크에 추가하고, 이 헤더에는 목적지 프로세스의 포트 번호가 담김
3. STP는 목적지 호스트 주소와 생성된 세그먼트(헤더 + 데이터)를 네트워크 계층에 전달한다.
4. 네트워크 계층은 이 세그먼트를 목적지 호스트의 STP에 전달합니다.
5. 수신측 STP는 세그먼트에서 포트 번호를 확인하고, 데이터를 추출한 후, 해당 포트 번호로 식별된 프로세스에 데이터를 전달한다.

b) 이전 1번을 약간 수정하여

- 최대 1192바이트의 데이터 청크 (헤더 4바이트 추가 확보)
- 목적지 호스트 주소 (IP 주소), 목적지 포트 번호
- 송신지 호스트 주소, 송신지 포트 번호 (회신 주소)

c) 아니다. 트랜스포트 계층은 종단 시스템에서 일어나는 프로토콜이기 때문에 네트워크 코어와는 관계가 없다.


### **R2.**

> 데이터 송수신의 절차와 트랜스포트 - 네트워크 계층의 작업을 일상적인 이미지와 연관해보라
> 

**a. 편지 송수신 프로토콜**

1. 가족 구성원(**송신 프로세스**):
    - 편지 본문 준비 - **데이터**
    - 목적지 집 주소 제공 - **IP**
    - 수신자 이름 제공 - **포트번호**
2. 발신특 편지를 모으고 배분하는 임무를 맡은 가족 구성원(**트랜스포트 계층**):
    - 편지 상단에 수신자 이름을 명확히 기재 - **헤더**
    - 편지를 봉투에 넣음 - **캡슐화**
    - 봉투에 목적지 집 주소 기재 - **IP**
    - 편지를 행성의 우편 서비스에 전달 - **네트워크 계층에 전달**
3. 우편 서비스의 역할 (**네트워크 계층**):
    - 편지 배달
4. 임무를 맡은 가족의 역할 (**수신자 트랜스포트 계층**):
    - 우편 서비스로부터 편지 수령
    - 봉투에서 편지 꺼내기
    - 편지 상단의 수신자 이름 확인
    - 해당 이름의 가족 구성원에게 편지 전달

**b. 우편 서비스의 봉투 처리(네트워크 계층과 데이터)**

- 우편 서비스는 봉투를 열 필요가 없고(데이터에는 무관심), 봉투에 적힌 주소(IP)만 확인함
  

### **R3.**

> UDP와 TCP에서 소켓을 활용한 수신자의 식별을 설명할 수 있는가?
> 

**UDP 소켓 식별**

- 목적지 IP 주소
- 목적지 포트 번호

이 두 가지 정보만으로 UDP 소켓을 유니크하게 식별할 수 있다

**TCP 소켓 식별**

- 출발지 IP 주소
- 출발지 포트 번호
- 목적지 IP 주소
- 목적지 포트 번호

위 네 정보를 합쳐 "4-tuple"이라고 부르며, TCP 연결을 유니크하게 식별 함

**차이점**

연결 지향성: TCP는 연결 지향적이므로 양방향 통신을 위해 더 많은 정보가 필요. UDP는 비연결성이므로 목적지 정보만으로 충분하다

멀티플렉싱: TCP는 하나의 IP/포트 조합으로 여러 연결을 처리할 수 있어 4-tuple이 필요하다. UDP는 단순히 목적지로 패킷을 전달한다

상태 유지: TCP는 연결 상태를 유지하므로 더 많은 식별 정보가 필요하지만 UDP는 상태를 유지하지 않음

신뢰성: TCP의 4-tuple 식별은 신뢰성 있는 데이터 전송을 보장하는 데 도움이 된다. UDP는 신뢰성보다는 속도에 중점을 둔다


### **R4.** p178~p179

> TCP와 비교했을 때 UDP를 실무에서 사용하는 이유를 설명해보라
> 

1 무슨 데이터를 언제 보낼지에 대해 애플리케이션 레벨에서 더 정교한 제어:

- UDP: 프로세스가 데이터를 전달하자마자 그 세그먼트를 즉시 네트워크 계층으로 전달한다.

- TCP: 혼잡제어 메커니즘과 연결설정 등으로 인해 지연이 발생한다
    
    실시간 애플리케이션은 최소 전송률을 요구할 때도 있고, 지나치게 지연되는 세그먼트 전송을 원하지 않으며, 조금의 데이터 손실은 허용할 수도 있으므로, TCP의 서비스 모델은 이러한 애플리케이션의 요구와는 맞지 않는다.
    

2 연결 설정이 없음: 

- UDP: 프로세스가 데이터를 전달하자마자 그 세그먼트를 즉시 네트워크 계층으로 전달한다.
- TCP: 혼잡제어 메커니즘과  three-way-handshake 연결설정 등으로 인해 지연이 발생한다
    
    즉 UDP에서는 연결을 설정하기 위한 어떤 지연도 없다. 이는 DNS가 UDP에서 동작하는 이유이다.
    

3 연결 상태가 없음: 

- UDP: 연결 상태를 유지하지 않으며 어떤 파라미터도 기록하지 않는다
- TCP: 종단 시스템에서 연결 상태를 유지한다. 이 연결 상태는 수신 버퍼와 송신 버퍼, 혼잡 제어 파라미터, 순서 번호, 확인응답 번호 파라미터 등이 필요하다
    
    이러한 이유로 일반적으로 특정 애플리케이션 전용 서버는 애플리케이션 프로그램이 TCP보다 UDP에서 동작할 때 일반적으로 좀 더 많은 액티브 클라이언트를 수용할 수 있다.
    

4 작은 패킷 헤더 오버헤드: 

- UDP: UDP는 세그먼트마다 8바이트의 헤더 오버헤드를 갖는다.
    - 출발지 포트 (16비트)
    - 목적지 포트 (16비트)
    - 길이 (16비트)
    - 체크섬 (16비트)
- TCP: TCP는 세그먼트마다 20~60바이트의 헤더 오버헤드를 갖는다
    - 출발지 포트 (16비트)
    - 목적지 포트 (16비트)
    - 순서 번호 (32비트)
    - 확인 응답 번호 (32비트)
    - 데이터 오프셋 (4비트)
    - 예약 필드 (3비트)
    - 제어 플래그 (9비트)
    - 윈도우 크기 (16비트)
    - 체크섬 (16비트)
    - 긴급 포인터 (16비트)
    - 옵션 (0-40바이트, 선택적)
  

### **R5.**

> TCP와 UDP의 이론적 특성을 넘어, 실제 인터넷 환경에서 프로토콜 선택에 영향을 미치는 현실적인 요인들을 고려할 수 있는가?
> 

**방화벽 통과 용이성**

TCP는 UDP보다 방화벽을 더 쉽게 통과할 수 있다. 많은 기업 네트워크와 방화벽이 UDP 트래픽을 차단하거나 제한하는 반면, TCP 트래픽(특히 HTTP나 HTTPS를 통한)은 일반적으로 허용된다.

**네트워크 품질 향상**

현대 네트워크의 품질이 크게 향상되어 TCP와 UDP의 성능 차이가 줄어들었다. 특히 미국과 유럽의 공용 네트워크에서는 패킷 손실과 재전송이 드물어, TCP 사용으로 인한 지연이 크게 감소했다.

**안정성과 품질 보장**

일부 스트리밍 서비스에서는 고품질 콘텐츠 전송을 위해 TCP를 선호한다. 예를 들어, 화면 공유나 고품질 비디오 스트리밍의 경우 프레임 손실을 최소화하기 위해 TCP가 더 적합할 수 있다.

**CDN 호환성**

많은 콘텐츠 전송 네트워크(CDN)가 TCP 기반 스트리밍을 지원하며, 이는 대규모 배포에 유리하다.

**버퍼링 기술의 발전**

현대 스트리밍 서비스는 10-30초의 버퍼를 사용하여 TCP의 신뢰성 있는 전송을 활용하면서도 부드러운 재생을 가능하게 한다.


### **R6.**

> UDP의 비신뢰성을 극복하고 애플리케이션 계층에서 신뢰성을 구현할 수 있는 방법을 이해하고 있는가?
> 

애플리케이션 계층 상에서 신뢰성을 자체적으로 구현하여 제공한다면 가능하다.

**신뢰성 구현 방법 예시**

1. 순서 번호 부여:
    
    각 패킷에 고유한 순서 번호를 부여하여 패킷의 순서를 추적
    
2. 확인 응답(ACK) 시스템:
    
    수신자가 패킷을 성공적으로 받았음을 알리는 ACK를 송신자에게 전송
    
3. 타임아웃 및 재전송:
    
    일정 시간 내에 ACK를 받지 못하면 패킷을 재전송
    
4. 슬라이딩 윈도우 프로토콜:
    
    Go-Back-N이나 Selective Repeat 등의 알고리즘을 사용하여 효율적인 패킷 관리(3.4절)

5. 체크섬(check sum):
    
    데이터 무결성을 확인하기 위해 체크섬을 사용
    
    - 송신자: 데이터를 일정 크기의 블록으로 나누고, 이를 더하여 체크섬을 계산한다.
    - 계산된 체크섬은 데이터와 함께 전송된다.
    - 수신자: 받은 데이터로 동일한 방식의 체크섬을 계산한다.
    - 계산된 체크섬과 받은 체크섬을 비교하여 데이터 무결성을 확인한다.
    - 불일치 시 데이터 손상이 의심되어 재전송을 요청할 수 있다.
6. 버퍼링:
    
    수신 측에서 패킷을 임시 저장하여 순서대로 처리한다
    
    - 수신 버퍼: 도착한 패킷을 임시 저장한다.
    - 순서 조정: 패킷이 순서대로 도착하지 않을 경우, 버퍼에서 올바른 순서로 재배열한다.
    - 흐름 제어: 송신자의 전송 속도가 수신자의 처리 속도보다 빠를 때 데이터 손실을 방지한다.
    - 지터 감소: 네트워크 지연 변동으로 인한 영향을 줄여 안정적인 데이터 스트림을 제공한다.
      

### **R7.**

> UDP 소켓의 식별 방식, UDP 헤더 구조, 그리고 수신 측에서 여러 발신자의 데이터를 구분하는 방법을 정확히 이해하고 있는가?
> 

두 UDP 세그먼트 모두 호스트 C의 같은 소켓(포트 번호 6789)으로 전달될 것이다. UDP 소켓은 목적지 IP 주소와 목적지 포트 번호의 두 가지 요소로 식별되기 때문이다.

호스트 C의 프로세스는 UDP 데이터그램 헤더에 포함된 출발지 정보를 확인함으로써 두 세그먼트가 서로 다른 호스트(A, B)에서 시작되었음을 알 수 있다.

- UDP 데이터그램 헤더 정보: 운영 체제는 수신된 UDP 세그먼트의 데이터뿐만 아니라 헤더 정보도 프로세스에 제공한다. 이 헤더에는 다음 정보가 포함된다:
    - **출발지 IP 주소**
    - **출발지 포트 번호**
    - 목적지 포트 번호
    - 데이터 길이
    - 체크섬
- 소켓 API 사용: 프로세스는 recvfrom()과 같은 소켓 API 함수를 사용하여 데이터를 수신할 때 출발지 주소 정보를 얻을 수 있다.

### **R8.**

> 웹 서버의 TCP 연결 처리 방식, 특히 초기 연결 수립과 이후의 데이터 통신에서 포트와 소켓의 동작 방식의 차이를 정확히 이해하고 있는가
> 

모든 연결 요청이 호스트 C의 같은 소켓으로 수신되는 것은 아니며, 다른 소켓을 통해 받을 때 그 소켓들이 모두 80번 포트를 갖는 것 또한 아니다. **80번 포트는 초기 연결 수립을 위해서만 사용되고, 실제 데이터 통신은 동적으로 할당된 다른 포트를 통해** 이루어진다.

1. 요청 수신:
    - 웹 서버는 80번 포트에서 들어오는 연결 요청을 수신한다.
    - **그러나 각 클라이언트 연결은 별도의 소켓으로 처리**된다.
2. 소켓 생성:
    - 서버는 각 **클라이언트 연결에 대해 새로운 소켓을 생성**한다.
    - 이 소켓들은 80번 포트가 아닌 다른 포트 번호를 사용한다.
3. 포트 할당:
    - 새로 생성된 **소켓들은 운영 체제에 의해 동적으로 할당된 임시 포트(ephemeral port)를 사용**한다.
    - 이 포트 번호는 일반적으로 **1024에서 65535 사이의 범위에서 할당**된다.
4. 연결 식별:
    - 각 연결은 클라이언트 IP 주소, 클라이언트 포트 번호, 서버 IP 주소, 서버의 동적 할당 포트 번호로 고유하게 식별된다.
5. 지속적 연결:
    - 지속적 연결을 사용하는 경우, 이러한 소켓과 포트 할당은 여러 요청-응답 주기 동안 유지된다.

## 3.4절
      
