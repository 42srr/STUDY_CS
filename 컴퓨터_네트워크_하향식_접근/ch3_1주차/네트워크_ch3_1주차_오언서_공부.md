## 3.1 트랜스포트 계층 서비스 및 개요

트랜스포트 계층은 애플리케이션 프로세스 간의 논리적인 통신을 제공하며, TCP와 UDP와 같은 프로토콜을 통해 구현됩니다. 주요 역할은:

1. **신뢰성 있는 통신 제공 (TCP)**: 데이터 손실이나 손상이 있을 수 있는 환경에서 안정적인 통신을 보장.
2. **전송률 제어 (TCP)**: 네트워크 혼잡을 방지하고 전송 속도를 조절.

트랜스포트 계층은 애플리케이션 메시지를 작은 세그먼트로 나누어 네트워크 계층에 전달하고, 수신 측에서 이를 다시 애플리케이션 프로세스로 전달합니다. TCP는 신뢰성 있는 전송을 제공하고, UDP는 비신뢰적이고 빠른 서비스를 제공합니다.

---

### 3.1.1 트랜스포트 계층과 네트워크 계층 사이의 관계

- **트랜스포트 계층**: 애플리케이션 프로세스 간 데이터 전송을 관리. 전송된 데이터를 네트워크 계층을 통해 다른 호스트로 전달.
- **네트워크 계층**: 호스트들 간의 논리적인 통신을 관리. 데이터를 패킷으로 나누고 최적의 경로를 통해 전달.

트랜스포트 계층은 네트워크 계층의 서비스 모델에 영향을 받으며, 네트워크 계층에서 제공하지 않는 서비스는 트랜스포트 계층에서 보완할 수 있습니다.

---

### 3.1.2 인터넷 트랜스포트 계층의 개요

인터넷에서 두 가지 주요 트랜스포트 계층 프로토콜을 제공합니다:

- **TCP (Transmission Control Protocol)**: 신뢰적인 연결 지향형 서비스.
- **UDP (User Datagram Protocol)**: 비신뢰적인 비연결형 서비스.

트랜스포트 계층은 세그먼트라는 단위로 데이터를 전송하며, 애플리케이션은 소켓을 사용해 TCP 또는 UDP를 선택합니다.

---

### TCP와 UDP 비교

| 기능                        | TCP                      | UDP                     |
|-----------------------------|--------------------------|-------------------------|
| **신뢰성**                   | 신뢰적 데이터 전송        | 비신뢰적 서비스           |
| **혼잡 제어**                 | 있음                     | 없음                    |
| **오류 검출**                 | 있음                     | 있음                    |

- **TCP**: 신뢰성 있는 전송, 흐름 제어, 순서 번호, 타이머 등을 사용해 정확하게 데이터 전송.
- **UDP**: 빠르지만 데이터의 정확성이나 순서를 보장하지 않음.

---

## 3.2 다중화와 역다중화

트랜스포트 계층은 **호스트 대 호스트** 전달을 **프로세스 대 프로세스** 전달로 확장합니다.

### 다중화(Multiplexing) & 역다중화(Demultiplexing)

- **다중화**: 출발지 호스트에서 여러 프로세스로부터 데이터를 수집하고 세그먼트로 만들어 네트워크 계층에 전달.
- **역다중화**: 수신지 호스트에서 세그먼트를 해당 애플리케이션 프로세스로 전달.

트랜스포트 계층은 **소켓**을 통해 데이터를 전달하며, 각각의 소켓은 유일한 식별자(포트 번호)를 가집니다. 세그먼트는 목적지 포트 번호를 포함하여 올바른 소켓으로 데이터를 전달합니다.

**UDP**: 각 소켓은 포트 번호로 식별되고, 트랜스포트 계층은 포트 번호를 기준으로 해당 소켓에 데이터를 전달합니다.


### 비연결형 다중화와 역다중화

```python
clientSocket = socket(AF_INET, SOCKET_DGRAM)
```
이 방법으로 UDP 소켓이 생성될 때, 트랜스포트 계층은 포트 번호를 소켓에게 자동으로 할당한다. 특히 UDP 포트로 사용하지 않는 1024 ~ 65535 사이의 포트 번호를 할당한다. <br>

다른 방법으로는 우리가 소켓을 생성한 뒤, 소켓 bind() 방식을 사용하여 특정번호를 UDP 소켓에 할당하기 위해 파이썬 프로그램에 한 줄을 추가할 수 있다.

```python
clientSocket.bind(('', 199157))
```
일반적으로 애플리케이션의 서버 측이 특정 포트 번호를 할당하는 것에 반하여, 애플리케이션의 클라이언트 측은 트랜스포트 계층이 포트 번호를 자동으로 할당한다.

### 연결지향형 다중화와 역다중화

TCP에서 역다중화를 수행하려면 TCP 소켓과 TCP 연결 설정을 이해해야 한다. TCP 소켓과 UDP 소켓의 주요 차이점은 TCP 소켓이 **4개의 요소**인 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호에 의해 식별된다는 것이다. 따라서 네트워크에서 TCP 세그먼트가 호스트에 도달하면, 호스트는 이 4개의 값을 사용하여 적절한 소켓으로 세그먼트를 전달한다. 이는 UDP와 다르게, 다른 출발지 IP나 포트 번호를 가진 TCP 세그먼트가 서로 다른 소켓으로 전달되는 이유이다.

#### TCP 연결 설정 및 역다중화

- **TCP 서버 애플리케이션**은 '환영 소켓'을 가지고 있으며, 이 소켓은 **포트 12000**에서 연결 설정 요청을 기다림
- **TCP 클라이언트**는 연결 요청을 보내기 위해 소켓을 생성하고, **목적지 포트 12000**으로 연결 설정 요청 세그먼트를 전송한다. 이 요청 세그먼트는 특별한 연결 설정 비트가 포함되어 있으며, **출발지 포트 번호**는 클라이언트가 선택한 번호이다.
- **서버 프로세스**는 목적지 포트 12000을 포함하는 세그먼트를 수신하면, 이 세그먼트를 연결 수락을 기다리는 서버 프로세스로 전달한다.

서버는 연결 요청 세그먼트에서 **4가지 값을 주목**한다:

1. 세그먼트의 **출발지 포트 번호**
2. **출발지 IP 주소**
3. 세그먼트의 **목적지 포트 번호**
4. **목적지 IP 주소**

서버는 이후 도착하는 모든 세그먼트가 이 4가지 값과 일치하면, 해당 세그먼트를 올바른 소켓으로 **역다중화**한다. 이후 클라이언트와 서버는 이 연결을 통해 데이터를 주고받을 수 있다.

#### 서버의 다중 TCP 소켓 지원

서버 호스트는 여러 개의 TCP 소켓을 동시에 지원할 수 있다. 각 소켓은 **4개 요소의 집합**에 의해 식별되며, 호스트에 도달한 TCP 세그먼트는 이 값들을 사용하여 적절한 소켓으로 전달된다.

### 웹 서버와 TCP

웹 서버는 **포트 번호**를 어떻게 사용할까?

- **출발지 IP**가 같지만 **출발지 포트**가 다른 세그먼트가 있을 수 있다. 웹 서버는 각 연결에 대해 **새로운 프로세스**를 생성하고, 각 프로세스는 **연결 소켓**을 통해 HTTP 요청을 수신하고 응답을 전송한다.
- 그러나 현대의 많은 **고성능 웹 서버**는 **하나의 프로세스**만 사용하며, 각 클라이언트의 새로운 연결에 대해 **새로운 스레드**를 생성한다. 각 스레드는 고유한 연결 소켓을 통해 요청과 응답을 처리한다.

#### 지속적인 vs 비지속적인 HTTP 연결

- **지속적인 HTTP**(keep-alive)를 사용하는 경우, 클라이언트와 서버는 **서버 소켓**을 통해 메시지를 교환한다. 연결이 끊어지지 않고 계속 유지된다.
- **비지속적인 HTTP**(새로운 연결마다 끊어짐)를 사용하는 경우, 각 요청/응답마다 **새로운 TCP 연결**이 생성되고 종료된다. 이로 인해 **매번 새로운 소켓**이 생성되고 종료되는 부담이 웹 서버에 커진다. 이는 성능에 상당한 영향을 미칠 수 있다.

## 3.3 비연결형 트랜스포트: UDP

### 목표: UDP 동작 원리 및 수행 작업 알아보기

트랜스포트 계층은 네트워크 계층과 애플리케이션 프로세스 간의 데이터를 전달하기 위해 **다중화와 역다중화** 서비스를 제공한다.

### UDP 특징

- **최소 기능**: UDP는 다중화, 역다중화, 간단한 오류 검사만 제공
- **비연결형**: 핸드셰이크 없이 데이터 전송 (TCP와 달리 연결 설정 없음)
- **빠름**: 연결 설정 지연이 없고, 헤더 오버헤드가 적음 (8바이트)
- **애플리케이션 예시**: DNS (DNS 질의는 UDP로 처리됨)

### UDP 동작 원리

1. 애플리케이션 프로세스가 메시지를 생성
2. UDP는 포트 번호와 헤더를 추가하여 네트워크 계층으로 전달
3. 수신 호스트에서 포트 번호를 통해 적절한 애플리케이션 프로세스로 전달

### UDP 사용 이유

- **정교한 제어**: 애플리케이션에서 데이터 전송 시 더 정교한 제어 가능
- **연결 설정 없음**: TCP처럼 연결 설정을 위한 지연 없음
- **연결 상태 없음**: UDP는 연결 상태를 유지하지 않음
- **작은 헤더 오버헤드**: UDP는 8바이트, TCP는 더 많은 오버헤드

### UDP vs TCP

- **혼잡 제어 부재**: UDP는 혼잡 제어가 없어 네트워크에서 패킷 손실이 발생할 수 있음
- **애플리케이션 신뢰성 제공**: 애플리케이션이 신뢰성 있는 데이터 전송을 제공할 수 있음

UDP는 실시간 애플리케이션이나 네트워크 관리 애플리케이션에서 많이 사용되며, 특히 DNS나 멀티미디어 애플리케이션에서 유용하다. UDP는 TCP보다 빠르지만, 혼잡 제어가 없기 때문에 손실률이 높아질 수 있다.

### 3.3.1 UDP 세그먼트 구조
- 애플리케이션 데이터는 UDP 데이터그램의 데이터 필드에 위치
- UDP 헤더는 2바이트 씩 구성된 단 4개의 필드만을 가짐

## 3.3.2 UDP 체크섬

### 동작 원리
- **송신 측**: 모든 16비트 워드의 합산 후 1의 보수를 취하고, 오버플로우는 윤회식 자리올림 처리. 결과는 UDP 세그먼트의 체크섬 필드에 삽입.
- **수신 측**: 체크섬 포함 모든 비트 워드를 더해 오류 검출. 합이 1이면 오류 없음, 0이면 오류 발생.

### UDP 체크섬 제공 이유
- 모든 링크에서 오류 검사를 보장할 수 없음.
- **종단과 종단 원칙**: UDP는 종단 기반으로 오류 검사 제공.
- UDP는 오류 검사만 제공하고 오류 회복 기능은 제공하지 않음.

---

## 3.4 신뢰적인 데이터 전송의 원리

### 신뢰적인 데이터 전송 문제
- 신뢰적인 데이터 전송 문제는 트랜스포트, 링크, 애플리케이션 계층 모두에서 발생할 수 있음.
- 신뢰적인 채널에서는 데이터가 손상되거나 손실되지 않음. TCP가 제공하는 서비스 모델.

### 3.4.1 신뢰적인 데이터 전송 프로토콜 구축

#### rdt1.0 (완벽한 신뢰적 채널)
- 송신자와 수신자는 각각 FSM (유한 상태 머신)을 통해 데이터를 전송하고 수신.
- **송신 측**: 데이터를 받아 패킷으로 만들어 전송.
- **수신 측**: 패킷을 받아 데이터 추출 후 상위 계층으로 전달.

#### rdt2.0 (비트 오류가 있는 채널)
- 패킷에서 비트 오류가 발생할 수 있음.
- **ARQ 프로토콜**: 오류 검출, 수신자 피드백 (ACK/NAK), 재전송.
- **패킷 순서 번호**: 패킷 순서를 확인해 재전송을 유도.
- 송신자는 ACK/NAK를 받으면 적절히 대처.

#### rdt3.0 (비트 오류와 손실 있는 채널)
- 패킷 손실을 고려한 신뢰적 데이터 전송.
- 송신자는 ACK 손실을 감지하고 일정 시간을 기다린 후 재전송.
- **타이머**: 송신자가 패킷을 보내고 일정 시간 후 ACK를 기다림.

### 3.4.2 파이프라이닝된 신뢰적인 데이터 전송 프로토콜

**rdt3.0**은 전송 후 대기 방식으로 성능에 한계가 있음. 이를 해결하기 위해 **파이프라이닝** 방식이 도입됨.

#### 해결책

- 송신자가 확인 응답을 기다리지 않고 여러 패킷을 동시에 전송하도록 허용.
- **파이프라이닝**: 여러 송신-수신 패킷을 파이프라인에 채워 넣는 방식.
    - **순서 번호의 범위**가 커져야 함:
        - 전송 중인 각 패킷은 고유한 순서 번호를 가져야 하며, 확인 응답이 오지 않은 패킷이 여러 개 있을 수 있기 때문.
    - 송신자와 수신자는 **패킷을 버퍼링**해야 함:
        - 송신자는 전송된 패킷을 확인 응답을 받을 때까지 버퍼링해야 하고, 수신자도 정확히 수신된 패킷을 버퍼링해야 함.
    - 필요한 **순서 번호 범위**와 **버퍼링 조건**은 손실된 패킷, 손상된 패킷, 지연된 패킷에 대한 처리 방식에 따라 달라짐.

#### 파이프라인 오류 회복의 두 가지 방법:
1. **GBN (Go-Back-N)**
2. **SR (Selective Repeat)**

### 3.4.2 GBN
- 송신자는 확인 응답을 기다리지 않고 여러 패킷을 전송할 수 있음
- 확인 응답이 안 된 패킷의 최대 수는 **N**으로 제한됨

#### 4개의 간격

1. **[0, base-1]**: 이미 확인 응답된 패킷
2. **[base, nextseqnum, base+N-1]**: 송신되었으나 확인 응답되지 않은 패킷
3. **[nextseqnum, base+N-1]**: 상위 계층에서 데이터가 오면 전송할 패킷
4. **base+N 이상**: 확인 응답되지 않은 패킷

#### 윈도 크기

- **윈도 크기 N**은 송신자가 동시에 확인 응답을 기다릴 수 있는 패킷 수를 의미
- **GBN은 슬라이딩 윈도** 방식 사용

#### 송신자의 세 가지 이벤트

1. **상위 계층 호출**: 윈도가 가득 차지 않으면 패킷 전송, 그렇지 않으면 대기
2. **ACK 수신**: 누적 확인 응답 처리
3. **타임아웃**: 확인 응답이 없는 패킷 재전송

#### 수신자의 행동

- 순서대로 패킷 수신 후 ACK 전송
- 순서가 틀린 패킷은 버리고, 마지막으로 올바른 패킷에 대한 ACK 전송

#### 이벤트 기반 프로그래밍

- 다양한 이벤트에 따라 프로토콜 동작을 구현

### 3.4.4 SR (Selective Repeat)

- **SR**은 오류가 발생한 패킷만 재전송 (개별 확인응답)
- **수신자**는 순서와 상관없이 손상 없이 수신된 패킷에 대한 확인응답을 보냄
- **빠진 패킷**은 버퍼에 저장하고, 순서대로 수신되면 상위 계층에 전달

#### SR 송신자 이벤트와 행동

1. **상위 계층 데이터 수신**
    - 순서번호가 송신자 윈도 내에 있으면 패킷을 송신, 그렇지 않으면 버퍼에 저장
2. **타임아웃**
    - 타이머는 손실된 패킷을 재전송 (각 패킷에 개별 논리 타이머 필요)
3. **ACK 수신**
    - ACK가 윈도 내에 있으면 그 패킷을 수신된 것으로 처리하고, 윈도 이동

#### SR 수신자 이벤트와 행동

1. **[rcv_base, rcv_base+N-1] 내의 순서번호 패킷 수신**
    - 수신된 패킷은 ACK하고, 순서대로 버퍼에서 패킷을 상위 계층으로 전달
2. **[rcv_base-N, rcv_base-1] 내의 순서번호 패킷 수신**
    - 이전에 확인응답한 패킷일지라도 재확인 응답을 보내야 함
3. **그 외의 패킷**은 무시

