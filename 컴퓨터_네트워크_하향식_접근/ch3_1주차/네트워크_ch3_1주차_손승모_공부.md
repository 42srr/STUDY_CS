# 3. 트랜스포트 계층

## 3.1 트랜스포트 계층 서비스 및 개요

- 트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 **논리적 통신**을 제공한다.
- 논리적 통신은 애플리케이션의 관점에서 보면 프로세스들이 동작하는 호스트들이 직접 연결된 것처럼 보인다는 것을 의미한다.
- 트랜스포트 계층 프로토콜은 네트워크 라우터가 아닌 종단 시스템에서 구현된다.
- 송신 측의 트랜스포트 계층은 송신 애플리케이션 프로세스로부터 수신한 메시지를 **트랜스포트 계층 세그먼트**라고 알려진 트랜스트 계층 패킷으로 변환한다.
- 애플리케이션 메시지를 트랜스포트 계층 세그먼트로 만들기 위해 작은 조각으로 분할하고 각각의 조각에 트랜스포트 계층 헤더를 추가함으로써 수행된다.
- 수신 측에서 네트워크 계층은 데이터그램으로부터 트랜스포트 계층 세그먼트를 추출하고 트랜스포트 계층 세그먼트를 보낸다
- 트랜스포트 계층은 수신 애플리케이션에서 세그먼트 내부의 데이터를 이용할 수 있도록 수신된 세그먼트를 처리한다.

### 3.1.1 트랜스포트 계층과 네트워크 계층 사이의 관계

- 트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 **프로세스들 사이의 논리적 통신**을 제공
- 네트워크 계층 프로토콜은 **호스트들 사이의 논리적 통신**을 제공한다.
- 트랜스포트 계층 프로토콜들은 종단 시스템에 존재한다.
- 종단 시스템 안에서 트랜스포트 프로토콜은 애플리케이션 프로세스에서 네트워크 경계까지 메시지를 운반하고 반대 방향으로 네트워크 계층에서 애플리케이션 프로세스로 메시지를 운반한다.
- 트랜스포트 계층이 제공할 수 있는 서비스는 하위 네트워크 계층 프로토ㄹ의 서비스 모델에 의해 제약받는다.
- 네트워크 계층 프로토콜이 호스트 사이에 전송되는 트랜스포트 계층 세그먼트에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다면, 트랜스포트 계층 프로토콜은 프로세스끼리 전송하는 메시지에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다.

### 3.1.2 인터넷 트랜스포트 계층의 개요

- 인터넷은 애플리케이션 계층에게 두 가지 구별되는 트랜스포트 계층 프로토콜을 제공한다

  - 비신뢰적이고 비연결형인 서비스를 요청한 애플리케이션에게 제공하는 **UDP**
  - 신뢰적이고 연결형 서비스를 요청한 애플리케이션에게 제공하는 **TCP**
- 인터넷에서 트랜스포트 계층 패킷을 **세그먼트**로 일컫는다.
- TCP에 대한 트랜스포트 계층 패킷을 세그먼트로 나타내면서, UDP에 대한 패킷을 데이터 그램으로 표현하도 한다.
- 그러나 네트워크 계층 패킷에 대해서도 **데이터그램**이라는 같은 용어를 사용하고 있다.
- 네트워크 계층 패킷에 대해 데이터그램이라는 용어를 사용한다.
- IP 서비스 모델은 호스트들 간에 논리적 통신을 제공하는 최선형 전달 서비스다

  - 호스트들 간에 세그먼트를 전달하기 위해 최대한 노력하지만, 어떤 보장도 하지 않는다는 것을 의미
  - 세그먼트 전달을 보장하지 않고 세그먼트가 순서대로 전달되는 것을 보장하지 않는다.
  - 세그먼트 내부 데이터의 무결성을 보장하지 않는다.
- **각 호스트가 적어도 하나의 IP주소를 갖고 있다.**
- UDP와 TCP의 가장 기본적인 기능은 종단 시스템 사이의 IP 전달 서비스를 종단 시스템에서 동작하는 두 프로세스 간의 전달 서비스로 확장하는 것이다.

  - IP(Internet Protocol)는 데이터를 한 기기(종단 시스템)에서 다른 기기로 전송하는 역할을 합니다.
  - 하지만 IP는 단순히 데이터 패킷을 한 컴퓨터에서 다른 컴퓨터로 전달하는 것만 담당할 뿐, 어떤 프로그램(프로세스)이 그 데이터를 보내고 받는지는 구분하지 않습니다.
  - 이때 UDP와 TCP가 필요해집니다:
    - **IP 전달 서비스** : 데이터를 컴퓨터 A에서 컴퓨터 B로 전송
    - **UDP/TCP의 확장** : 컴퓨터 A의 특정 프로그램에서 컴퓨터 B의 특정 프로그램으로 전송
  - 예를 들어 설명하자면:
    - 여러분의 컴퓨터(종단 시스템 A)에서 웹 서버(종단 시스템 B)로 데이터를 보낼 때, IP는 단지 "A에서 B로 보내는 데이터"라는 정보만 처리합니다.
    - 하지만 실제로는 A 컴퓨터의 웹 브라우저(프로세스 1)가 B 서버의 웹 서버 프로그램(프로세스 2)과 통신하고 있는 것입니다.
  - UDP와 TCP는 이 두 프로세스 간의 통신을 가능하게 해주는 추가적인 정보(포트 번호 등)를 제공함으로써 IP의 기능을 "확장"합니다. 이를 통해 하나의 컴퓨터에서 실행 중인 여러 프로그램들이 각각 다른 컴퓨터의 프로그램들과 독립적으로 통신할 수 있게 됩니다.
- '호스트 대 호스트 전달'을 '프로세스 대 프로세스 전달'로 확장하는 것을 **트랜스포트 계층 다중화**와 **역다중화**라고 부른다.
- UDP와 TCP는 헤더에 오류 검출 피드를 포함함을써 무결성 검사를 제공한다.
- 최소한의 두 가지 트랜스포트 계층 서비스(프로세스 대 프로세 데이터 전달과 오류 검출)가 UDP가 제공하는 유일한 두 가지 서비스다.
- UDP는 IP와 마찬가지로 비신뢰적인 서비스다.
- UDP는 하나의 프로세스에 의해 전송된 데이터가 손상되지 않고(일부 또는 데이터 전부) 목적지 프로세스에 도착한다는 것을 보장하지 않는다.
- TCP는 신뢰적인 데이터 전송을 제공한다.
- 흐름 제어, 순서 번호, 확인 응답, 타이머를 사용함으로써 TCP는 송신하는 프로세스로부터 수신하는 프로세스에게 데이터가 순서대로 정확하게 전달되도록 확실하게 한다.
- TCP는 혼잡제어를 사용한다.
- TCP 연결이 과도한 양의 트래픽으로 모든 통신하는 호스트들 사이의 스ㅣ치와 링크를 혼잡하게 하는 것을 방지하는 것이 TCP 혼잡 제어다.
- TCP는 혼잡한 네트워크 링크에서 각 TCP 연결이 링크의 대역폭을 공평하게 공유하여 통과하도록 해준다. 이것은 송신측의 TCP가 네트워크에 보낼 수 있는 트래픽을 조절함으로써 수행된다
- UDP 트래픽은 조절되지 않는다.
- UDP 트랜스포트 프로토콜을 사용하는 애플리케이션은 허용이 되는 한 그것이 만족하는 어떤 속도로든 전송할 수 있다.

## 3.2 다중화와 역다중화

- 목적지 호스트에서의 트랜스포트 계층은 바로 아래의 네트워크 계층으로부터 세그먼트를 수신한다.
- 소켓을 통해 네트워크에서 프로세스로 데이터를 전달하고, 또한 프로세스로부터 네트워크로 데이터를 전달하는 출입구 역할을 한다.
- 수신 측 호스트의 트랜스포트 계층은 실제로 데이터를 직접 프로세스로 전달하지 않는다. 대신에 중간 매개자인 소켓으로 전달한다.
- 트랜스포트 계층 세그먼트는 적절한 소켓으로 향하게 하기 위해 세그먼트에 필드 집합을 갖고 있다.
- 수신 측의 트랜스포트 계층은 수신 소켓을 식별하기 위해 필드를 검사한다. 그리고 이 세그먼트를 해당 소켓으로 보낸다.
- 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 **역다중화**라고 한다.
- 출발지 호스트에서 소켓으로부터 데이터를 모으고, 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보(나중에 역다중화에 사용된다)로 캡슐화되고 그 세그먼트들을 네트워크 계층으로 전달하는 작업을 **다중화**라고 한다.
- 트랜스포트 계층 다중화의 요구사항
  - 소켓은 유일한 식별자를 갖는다
  - 각 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 특별한 필드를 갖는다.
    - 특별할 필드라는 것은 **출발지 포트 번호 필드**와 **목적지 포트 필드**다
- 각각의 포트 번호는 0~65535까지의 16비트 정수다.
- 그중에서 0~1023까지의 포트 번호를 **잘 알려진 포트 번호**라고 하여 사용을 엄격하게 제한하고 있다.
- 과정
  - 호스트의 각 소켓은 포트 번호를 할당받는다.
  - 세그먼트가 호스트에 도착하면 트랜스포트 계층은 세그먼트 안의 목적지 포트 번호ㄹ 검사하고 상응하는 소켓으로 세그먼트를 보낸다.
  - 세그먼트의 데이터는 소켓을 통해 해당되는 프로세스로 전달된다.

#### 중간정리 (by claude)

##### 다중화

1. **출발지 호스트(송신 측 컴퓨터)** :

* 여러분의 컴퓨터나 스마트폰과 같이 데이터를 보내는 장치입니다.

2. **소켓** :

* 컴퓨터 내에서 실행 중인 프로그램들(웹 브라우저, 이메일 앱, 게임 등)이 네트워크 통신을 위해 사용하는 통로입니다.
* 각 프로그램은 자신만의 소켓을 통해 데이터를 내보냅니다.

3. **다중화 과정** :

* 하나의 컴퓨터에서 여러 프로그램들이 동시에 데이터를 보내려고 합니다.
* 운영체제는 각 프로그램의 소켓으로부터 데이터를 수집합니다.
* 각 데이터에 출발지 포트 번호와 목적지 포트 번호를 포함한 헤더를 추가합니다.
* 이렇게 헤더가 추가된 데이터 단위를 "세그먼트"라고 부릅니다.
* 이 세그먼트들을 IP 계층(네트워크 계층)으로 전달합니다.

다중화를 우체국 예시로 다시 설명하면:

* 한 사무실 건물(컴퓨터)에 여러 직원들(프로그램들)이 있습니다.
* 각 직원은 자신의 편지(데이터)를 보내고 싶어합니다.
* 우체국 직원(운영체제)은 모든 직원들의 편지를 수거합니다.
* 각 편지에 보내는 사람의 이름과 주소, 받는 사람의 이름과 주소가 적힌 봉투(헤더)를 씌웁니다.
* 이 편지들을 한꺼번에 배달 트럭(네트워크 연결)에 실어 보냅니다.

이것이 다중화입니다  즉 다중화는 여러 출처에서 오는 데이터를 모아서 하나의 통신 채널로 내보내는 과정입니다.

##### 역다중화

역다중화(demultiplexing)는 다중화의 반대 과정으로, 수신 측 컴퓨터에서 일어나는 작업입니다. 다음과 같이 설명할 수 있습니다:

1. **수신 측 호스트(목적지 컴퓨터)** :

* 데이터를 받는 컴퓨터나 장치입니다.

2. **역다중화 과정** :

* 네트워크(IP) 계층으로부터 여러 세그먼트들을 전달받습니다.
* 각 세그먼트의 헤더에 있는 목적지 포트 번호를 확인합니다.
* 이 포트 번호를 기반으로 세그먼트를 올바른 소켓(프로그램)에 전달합니다.
* 헤더는 제거되고 순수한 데이터만 해당 프로그램에 전달됩니다.

3. **포트 번호의 역할** :

* TCP/UDP 헤더에 있는 목적지 포트 번호가 핵심 정보입니다.
* 이 번호를 통해 어떤 프로그램(프로세스)이 데이터를 받아야 하는지 결정합니다.

우체국 예시로 계속 설명하면:

* 배달 트럭(네트워크)이 건물(수신 컴퓨터)에 여러 편지(세그먼트)를 배달합니다.
* 우편물 분류직원(운영체제)은 각 편지 봉투에 적힌 수신자 이름과 방 번호(포트 번호)를 확인합니다.
* 그리고 각 편지를 올바른 사람(프로그램)에게 전달합니다.
* 수신자는 봉투(헤더)를 열고 편지 내용(데이터)만 읽습니다.

예를 들어:

* 웹 브라우저는 보통 80번이나 443번 포트로 오는 데이터를 받습니다.
* 이메일 클라이언트는 25번(SMTP) 또는 110번(POP3) 포트로 오는 데이터를 받습니다.

이런 식으로 하나의 컴퓨터가 여러 프로그램을 위한 데이터를 동시에 수신하더라도, 역다중화 과정을 통해 각 데이터가 올바른 프로그램에 전달되는 것입니다.

#### 비연결형 다중화와 역다중화 (UDP)

- UDP 소켓이 목적지 IP 주소와 목적지 포트 번호로 구성된 두 요소로 된 집합에 의해 식별된다.
- 2개의 UDP 세그먼트가 출발지 IP주소와 출발지 포트 번호가 모두 다르거나 두 개 중 어느 하나가 다를지라도, 같은 목적지 IP 주소와 목적지 포트 번호를 가지면 2개의 세그먼트는 같은 목적지 소켓을 통해 같은 프로세스로 향할 것이다.
- 출발지 포트 번호는 세그먼트에서 '회신 주소'의 한 부분으로 사용된다.

#### 연결지향형 다중화와 역다중화 (TCP)

- TCP 소켓과 UDP 소켓의 다른 점은 TCP 소켓은 4개의 요소 집합 (four-turple)에 의해 식별된다는 것이다.
  - 출발지 IP 주소
  - 출발지 포트 번호
  - 목적지 IP 주소
  - 목적지 포트 번호
- UDP와 달리 다른 출발지 주소 또는 다른 출발지 포트 번호를 가지고 도착하는 2개의 TCP 세그먼트는 2개의 다른 소켓으로 향한다.
- 서버 호스트는 동시에 존재하는 많은 TCP 소켓을 지원할 수 있다.
- 이 각각의 소켓은 프세스에 접속되어 있으며, 이들 소켓은 4개의 요소의 집합에 의해 식별된다.

#### 웹서버와 TCP

- 연결 소켓과 프로세스 사이에 항상 일대일 대응이 이루어지는 것은 아니다.
- 오늘날의 많은 고성능 웹 서버는 하나의 프로세스만 사용한다
- 그러면서 각각의 새로운 클라이언트 연결을 위 새로운 열결 소켓과 함께 새로운 스레드를 생성한다.
- 만약 클라이언트와 서버가 지속적인 HTTP를 사용한다ㄴ, 지속적인 연결의 존속 기간에 클라이언트와 서버는 같은 서버 소켓을 통해 HTTP 메시지를 교환할 것이다.
- 만약 클라이언트와 서버가 비지속적인 HTTP를 사용한다면 모든 요청/응답 마다 새로운 TCP 연결이 생성되고 종료될 것이다.

## 3.3 비연결형 트랜스포트 : UDP

- 트랜스포트 계층 프로토콜이 할 수 있는 최소 기능으로 동작한다.
- UDP는 다중화/역다중화 기능과 간단한 오류 검사 기능을 제외하면 IP에 아무것도 추가하지 않는다.
- UDP는 애플리케이션 프로세스로부터 메시지를 가져와서 다중화/역다중화 서비스에 대한 출발지 포트 번호 필드와 목적지 포트 번호 필드를 첨부하고 다른 두 필드를 추가한 후에 최종 세그먼트를 네트워크 계층으로 넘겨준다.
- 네트워크 계층은 트랜스포트 계층 세그먼트를 IP 데이터그램으로 캡슐화하고 세그먼트를 수신 호스에게 전달하기 위해 최선을 다한다.
- 만약 세그먼트가 수신 호스트에 도착한다면, UDP는 세그먼트의 데이터를 해당하는 애ㄹ리케이션 프로세스로 전달하기 위해 목적지 포트 번호를 사용한다.
- UDP는 세먼트를 송신하기 전에 송신 트랜스포트 계층 개체들과 수신 트랜스포트 계층 개체들 사이에 핸드셰이크를 사용하지 않는다.
- 이런 이유로 UDP를 비연결형이라고 한다.
- 많은 애플리케이션이 UDP에 적합한 이유
  - 무슨 데이터를 언제 보낼지에 대해 애플리케이션 레벨에서 더 정교한 제어
  - 연결 설정이 없음
  - 연결 상태가 없음.
  - 작은 패킷 헤더 오버헤드
- 애플리케이션이 UDP를 사용할 때도 신뢰적인 데이터 전송이 가능하다.

### 3.3.1 UDP 세그먼트 구조

- 애플리케이션 데이터는 UDP 데이터그램의 데이터 필드에 위치한다.
- UDP 헤더는 2바이트씩 구성된 단 4개ㅣ 필드만을 갖는다.
- 체크섬은 세먼트 오류가 발생했는지를 검사하기 위해 수신 호스트가 사용한다.

### 3.3.2 UDP 체크섬

- 오류 검출을 위한 것이다.
- 체크섬은 세그먼트가 출발지로부터 목적지로 이동했을 때 UDP 세그먼트 안의 비트에 대한 변경사항이 있는지 검사하는 것이다.
- 송신자 측에서 UDP는 세그먼트 안에 있는 모든 16비트 워드의 합산에 대해 다시 1의 보수를 수행하며, 합산 과정에서 발생하는 오버플로는 윤회식 자리 올림을 한다.
- 이 결괏값이 UDP 세그먼트의 체크섬 필드 삽입된다.
- UDP가 체크섬을 제공하는 이유
  - 출발지와 목적지 사이의 모든 링크가 오류 검사를 제공한다는 보장이 없기 때문이다.
  - 세그먼트들이 정확하게 링크를 통해 전송되었을지라도, 세그먼트가 라우터의 메모리에 저장될 때 비트 오류가 발생할 수가 있다.
- 주어진 링크 간의 신뢰성과 메모리의 오류 검사가 보장되지도 않고, 종단 간의 데이터 전송 서비스가 오류 검사를 제공한다면 UDP는 종단 기반으로 트랜스포트 계층에서 오류 검사를 제공해야만 한다.
- UDP는 오류 검사ㄹ 제공하지만, 오류를 회복하기 위한 어떤 일도 하지 않는다.
- 일부 UDP 구현에서는 손상된 세그먼트를 그냥 버리기도 하고 다른 구현에서는 경고와 함께 손상된 세그먼트를 애플리케이션에게 넘겨주기도 한다.

## 3.4 신뢰적인 데이터 전송의 원리

- 신뢰적인 데이터 전송을 구현하는 문제는 트랜스포트 계층뿐만 아니라 링크 계층과 애플리케이션 계층에서도 발생한다.
- 신뢰적인 데이터 전송 프로토콜 (reliable data transfer protocol)
- 우리가 여기서 논의하는 과정에서 채택할 한 가지 가정은 보내진 패킷의 일부 손실될 수도 있겠지만 보내진 순서대로 전달되리라는 것을 가정
- 즉 하부 채널은 패킷의 순서를 바꾸지 않는다.
- 이제부터 프로토콜 데이터 단위에 대해 세그먼트 보다는 패킷이라는 용어를 사용한다.

### 3.4.1 신뢰적인 데이터 전송 프로토콜의 구축

#### 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송 : rdt 1.0

- 환경 자체가 reliable
- 즉 transport layer 할 일 크게 없음

#### 비트 오류가 있는 채널상에서의 신뢰적 데이터 전송 : rdt 2.0 ~ rdt:2.2

##### rdt 2.0

- bit error 여부 판단
- 체크섬 사용 (헤드에 체크섬 필드 추가) -> 이건 dest의 경우
- src는 dest가 피드백을 해줌 (ACK와 NAK)
- ACK : 긍정 확인 응답
- NAK : 부정 확인 응답
- 자동 재전송 요구 프로토콜을 해줌
  - 오류 검출
  - 수신자 피드백
  - 재전송
- 전송 후 대기 (stop - and -wait)프로토콜을 사용
  - 데이터가 보내는 것을 멈추고 피드백을 대한다 -> 비효율적
- 치명적인 결함이 있다.
  - ACK와 NAK 패킷에 대한 체크섬 비트를 추가할 필요가 있다.
  - 손상된 ACK 또는 NAK를 처리하기 위한 가능성
    - 중복 패킷을 전송한다.

##### rdt 2.1

- 순서번호를 삽입하는 방식
- 시퀀스 넘버가 길어질수록 헤더가 커짐 이는 오버헤드의 염려성
- 그러나 1bit만 있으면 됨
  - stop & wait 이므로 1비트만 있으면 됨
  - 이는 RDT only

##### rdt 2.2

- 비트 오류를 갖는 채널을 위한 NAK가 없는 신뢰적인 데이터 전송 프로토콜
- 효율성 개선
- ACK 세그먼트 헤드에 마지막 수신된 순서 번호 포함
  - 0 -> 1 -> 0 -> 1

#### 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송 : rdt 3.0

- bit error + packet loss -> timer로 해결
- 중복 데이터 패킷의 우려가 있으나 이는 2.2에서 해결했다.

### 3.4.2 파이프라이닝된 신뢰적인 데이터 전송 프로토콜

- RTT (Round Trip Time) : 두 종단 시스템 사이의 광속 왕복 전파 지연
- 전송 후 대기 방식은 많은 시간을 기다려야 한다.
- 하지만 파이프라이닝을 통해 시간을 효율적으로 개선할 수 있다.
- 파이프라이닝은 확인응답을 기다리지 않고 여러 패킷을 전송하도록 허용하는 것
- 이를 위해서 지켜야할 규칙
  - 순서 번호의 범위가 커져야 한다.
  - 프로토콜의 송신 측과 수신 측은 패킷 하나 이상을 버퍼링 해야한다. 즉 최소한 송신자는 전송되었으나 확인 응답되지 않은 패킷을 버퍼링 해야한다.
- 필요한 순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜이 손실 패킷과 손상 패킷 그리고 상당히 지연된 패킷들에 대해 응답하는 방식에 달려있다.

### 3.4.3 GBN

- 송신자는 확인응답을 기다리지 않고 여러 패킷을 전송할 수 있다.
- window : ACK 없이 한 번에 보낼 수 있는 양, inflight-packet 포함 가능크기
- 프로토콜이 동작할 때 이 윈도는 순서 번호 공간에서 오른쪽으로 이동된다.
- 이런 이유로 GBN을 슬라이딩 윈도 프로토콜이라고 부른다.
- sliding window이기 때문에 중간에 패킷 loss가 나면 윈도우는 움직이지 않는다.
- 즉 ACK sequence number는 sequence number까지 모든 패킷을 잘 받았다는 것을 의미한다.
- GBN은 타임아웃 이벤트에 반응해야한다.
  - 만약 타임아웃이 발생한다면 송신자는 이전에 전송되었지만 아직 확인 응답되지 않은 모든 패킷을 다시 송신한다.
  - 가장 오래된 기준으로 타이머를 맞춘다
  - 타임아웃이 될 경우 window에 있는 모든 애들을 재전송한다.
- GBN은 프로토콜에서 수신자는 순서가 잘못된 패킷들을 버린다. 이는 구현하기 나름이긴하다.

### 3.4.3 SR

- 선택적 재전송
- 리시버는 무조건 버퍼링이 필요하다.
- 수신자에서 오류가 발생한 패킷을 수신했다고 의심되는 패킷만을 송신자가 다시 전송하므로 불필요한 재전송을 피한다.
- 개벌적인 확인응답을 요구한다.
- window와 sequence number와의 관계에서 sequence number가 window의 2배 보다 작을시 이 패킷이 새로운 패킷인지 재전송이 된 것인지 헷갈린다.
- 그러므로 n = 2w이상을 가져야 한다.
