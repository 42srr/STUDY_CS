# 4. 네트워크 계층 : 평면도

- 네트워크 계층은 서로 상호작용하는 데이터 평면, 제어 평면 두 부분으로 나눌수 있습니다.
- 이번 장에서는 데이터 평면이 어떤 기능하는지를 배울 것입니다.
- 라우터별 제어는 네트워크 계층의 기능은 한 라우터의 입력 링크에 도착한 데이터그램이 다른 한 목적 라우터의 출력 링크에 어떻게 도착하는 지 결정합니다.

## 4.1 네트워크 계층 개요

<img src="4_1.png" width="500">

- 위 그림은 H1과 H2의 경로상에 여러 라우터와 두 호스트 H1, H2로 이루어진 네트워크 입니다.
- H1이 H2에 정보를 보낼 때, H1 네트워크 계층은 H1의 트랜스포트 계층으로부터 세그먼트를 얻어 데이터그램으로 캡슐화 시킨 후, 라우터 R1에게 데이터 그램을 보냅니다.
- 수신 호스트 H2의 네트워크 계층은 트랜스포트 계층 세그먼트를 추출하여 H2 트랜스포트 계층까지 전달합니다.
- 각 라우터의 데이터 평면 역할은 입력 링크에서 출력 링크로 데이터 그램을 전달하는 것입니다.
- 네트워크 제어 평면의 근본적인 역할은 데이터 그램이 출발 호스트에서 목적 호스트까지 잘 전달되게끔 로컬 포워딩, 라우터별 포워딩을 대응 시키는 것입니다.

### 4.1.1 포워딩과 라우팅 : 데이터 평면과 제어 평면

- 포워딩(전달)
  - 패킷이 라우터의 입력 링크로 들어왔을 때, 라우터는 해당 패킷을 적절한 출력 링크로 이동 시켜야합니다.
  - R1 라우터에 H1에서 패킷이 전달 됐을 떄, R1 라우터는 H2로 가는 다음 라우터에 전달이 되어야합니다.
  - 포워딩은 매우 짧은 시간 단위를 갖고, 대표적으로 하드웨어에서 실행됩니다.
- 라우팅

  - 송신자가 수신자에게 패킷을 전송할 때, 네트워크 계층은 패킷 경로를 결정해야합니다.
  - 해당 경로를 계산하는 알고리즘을 라우팅 알고리즘이라고 합니다.
  - 라우팅 경우, 네트워크 전반에 걸쳐 출발지에서 목적지까지 데이터그램의 종단 간의 경로를 결정합니다.

- 간단하게 포워딩과 라우팅의 예시를 네비게이션으로 들어보려합니다.
- 라우팅의 경우, 네비게이션에 목적지를 입력했을 때, 출발지에서 목적지까지 가는 경로을 계획해줍니다. 어떤 고속도를 탈지, 국도를 이용할지 등 최적의 길을 찾는 과정이 라우팅과 비슷합니다.
- 포워딩의 경우, 네비게이션이 교차로나 신호등을 만났을 때, 어떤 방향으로 갈지 안내해주는 것과 포워딩은 비슷합니다.

<img src="4_2.png" width="500">

- 네트워크 라우터의 필수 요소는 포워딩 테이블입니다.
  - 라우터는 도착하는 패킷 헤더의 필드값을 통해 포워딩 테이블의 내부 색인으로 사용하여 패킷을 전달합니다.
  - 포워딩 테이블 엔트리에 저장되어 있는 헤더의 값은 해당 패킷이 전달되어야 할 라우터의 외부 링크 인터페이스를 나타냅니다.
- 위 그림에서 헤더값 0110 패킷이 라우터에 도착하고, 라우터는 포워딩 테이블 기준으로 출력 링크 2번으로 전달합니다.

#### 제어 평면 : 전통적인 접근 방법

- 라우팅 알고리즘은 라우터의 포워딩 테이블의 내용을 결정합니다.
- 라우팅 알고리즘은 가각의 모든 라우터에서 실행됩니다.
- 라우팅은 포워딩과 라우팅 기능을 모두 갖고 있어야 합니다.
- 한 라우터의 라우팅 알고리즘 기능은 다른 라우터의 라우팅 알고리즘과 소통하며 포워딩 테이블의 값을 계산합니다.
- 소통이 어떻게 이루어지는 지는 5장에서 배웁니다.

#### 제어 평면 : SDN 접근 방법

<img src="4_3.png" width="500">

- 물리적으로 분리된 원격 컨트롤러 컴퓨터와 각각 라우터에 의해 사용될 포워딩 테이블을 분배하는 다른 접근법을 보여줍니다.
- 라우터와 원격 컨트롤러는 포워딩 테이블과 그 밖의 라우팅 정보를 포함한 메시지를 교환함으로 소통을 합니다.
- 원격 제어가 포워딩 테이블을 계산 및 분배하는 동안 라우팅 기기는 포워딩만 수행합니다.
- 네트워크가 소프트웨어적으로 정의되었을 때 포워딩 테이블을 계산하는 컨트롤러는 라우터와 상호작용을 하며 소프트웨어에서 실행이됩니다.

### 4.1.2 네트워크 서비스 모델

- 네트워크 서비스 모델은 송수신 호스트 간 패킷 전송 특성을 정의합니다.
- 네트워크 계층이 제공하는 서비스는 다음과 가틋빈다.

1. 보장된 전달
   - 해당 서비스는 패킷이 출발지 호스트에서 목적지 호스트까지 도착하는 것을 보장합니다.
2. 지연 제한 이내의 보장된 전달
   - 패킷의 전달 보장 뿐만 아니라 호스트 간의 특정 지연 제한 안에 전달됩니다.
3. 순서화 패킷 전달
   - 패킷이 목적지에 송신된 순서대로 도착하는 것을 보장합니다.
4. 최소 대역폭 보장
   - 송신과 수신 호스트 사이에 특정한 비트율의 전송 링크를 에뮬레이트합니다.
   - 송신 호스트가 특정 비트들을 특정 비트율 이하로 전송하는 한, 모든 패킷은 목적지에 전달 됩니다.
5. 보안 서비스
   - 네트워크 계층은 모든 데이터그램을 출발지 호스트에서 암호화하고, 목적지 호스트에서 해독 할 수 있게 트랜스포트 계층에서 세그먼트에 대한 기밀성을 유지합니다.

인터넷 네트워크 계층은 최선형 서비스라고 알려진 서비스를 제공합니다.

- 최선형 서비스의 특징
  - 패킷을 보내는 순서대로 수신을 보장하지 않습니다.
  - 목적지까지의 전송을 보장할 수 없습니다.
  - 종단 시스템 간의 지연이 보장 되지 않습니다.
  - 보장된 최소 대역폭이 없습니다.
- 쓸모 없어 보이지만, 적절한 대역폭 공급 및 대역폭 적응형 애플리케이션 레벨의 프로토콜과 결합된 넷플릭스 및 스트리밍 비디오 서비스 범위의 애플리케이션을 가능하게 할만큼 충분히 좋다고 입증되었다고 합니다.

## 4.2 라우터 내부에는 무엇이 있을까?

<img src="4_4.png" width="500">

- 입력 포트
  - 입력 포트의 맨 왼쪽 박스, 출력 포트의 오른쪽 박스는 라우터로 들어오는 입력 링크로, 물리 계층 기능을 수행합니다.
  - 입력 포트는 들어오는 링크의 반대편에 있는 링크 게층과 상호 운용하기 위해 필요한 링크 게층 기능을 수행합니다. 입력 및 출력 포트에서 미들 박스로 표시됩니다.
  - 가장 중여한 것은 입력 포트에서 검색 기능을 수행한다는 것입니다. 가장 오른쪽 박스에서 발생하며, 포워딩 테이블을 참조하여 도착된 패킷이 스위치 구조를 통해 라우터 출력 포트를 결정합니다.
  - 저에 패킷은 입력 포트에서 라우팅 프로세스로 전달됩니다.
  - 여기서의 포트는 물리적 입출력 라우터 인터페이스를 의미합니다.
- 스위치 구조
  - 스위치 구조는 라우터의 입력 포트와 출력 포트를 연결합니다.
  - 스위치 구조는 라우터 내부에 포함되어 있습니다.
- 출력 포트
  - 출력 포트는 스위치 구조에서 수신한 패킷을 저장하고 필요한 링크 계층 및 물리 계층 기능을 수행해 출력 링크로 패킷을 전송합니다.
  - 릉크가 양뱡향인 경우, 출력 포트는 일반적으로 동일한 링크의 입력 포트와 한 쌍을 이룹니다.
- 라우팅 프로세스
  - 제어 평면 기능을 수행합니다.
  - 기존 라우터에서 라우팅 프로토콜 실행하고, 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하며 라우터의 포워딩 테이블을 계산합니다.
  - SDN 라우터에서는 원격 컨트롤러와 통신하여 원격 컨트롤러에서 계산된 포워딩 테이블 엔트를 수신하고 라우터의 입력 포트에 엔트리 설치합니다.
- 라우터의 입력 포트, 출력 포트, 스위치 구조는 항상 하드웨오로 구현되어 있습니다.
- 제어 평면 기능은 소프트웨어로 구현되며 라우팅 프로세스(CPU)에서 실행됩니다

## 4.2.1 입력 포트 처리 및 목적지 기반 전송

<img src="4_5.png" width="500">

- 입력 포트의 라인 종단 기능과 링크 계층 처리는 라우터의 개별 입력 링크와 관련된 물리 계층 및 데이터 링크 계층을 구현한다.
- 입력 포트에서 수행되는 검색은 라우터 동작의 핵심입니다.
- 라우터는 포워딩 테이블을 사용해 도착 패킷이 스위치 구조 통해 전달되는 출력 포트를 검색합니다.
- 포워딩 테이블은 라우팅 프로세스에서 계산 및 갱신된 원격 SDN 컨트롤러에서 수신됩니다.
- 포워딩 테이블은 라우팅 프로세서에서 맨위 그림과 같이 각 라인 카드로 복사됩니다. 각 라인이 복사본을 사용하여 패킷 단위로 중앙 집중식 라우팅 프로세서를 호출하지 않게 되어 병목 현상을 피할 수 있습니다.

## 4.2.2 스위칭

### 메모리를 통한 교환

<img src="4_6.png" width="500">

- 가장 단순한 초기의 라우터는 CPU를 직접 제어해 입력 포트와 출력 포트 사이에서 패킷을 스위칭하는 전통적인 컴퓨터입니다.
- 입력 포트와 출력 포트는 운영체제에서 전통적인 I/O 장치처럼 작동합니다.

1. 패킷이 도착하면 입력 포트는 라우팅 프로세서에게 인터럽트를 보내 패킷을 프로세서 메모리에 복사합니다.
2. 라우팅 프로세서는 헤더에서 목적지 주소를 추출합니다.
3. 포워딩 테이블에서 출력 포트를 찾아 패킷을 출력 포트의 버퍼에 복사합니다.

- 해당 시나리오에서 메모리 대역폭이 초당 최대 B인 패킷을 메모리에 쓰거나 메모리에서 읽을 수 있는 경우 전달 처리량은 B/2보다 작아야합니다.
- 목적지 포트가 다른 경우 공유 시스템 버스를 통해 한 번에 하나의 메모리 읽기/쓰기 작업을 수행할 수 있기 때문에 두 패킷을 동시에 전달할 수 없습니다.

### 버스를 통한 교환

<img src="4_7.png" width="500">

- 입력 포트는 라우팅 프로세스의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷을 전송합니다.
- 일반적으로 미리 준비된 입력 포트 스위치 내부 레이블이 로컬 출력 포트를 나타내는 패킷에게 전송되거나 버스에서 패킷을 전송해 수행됩니다.
- 모든 출력 포트에 패킷이 수신되지만 레이블과 매치되는 포트만 패킷을 유지합니다.
- 레이블은 스위치 내 버스를 통과하기 위해서만 사용되어 출력 포트에서 제거됩니다.
- 동시에 여러 패킷이 도착하면 한 번에 하나의 패킷만 버스를 통과할 수 있어, 하나를 제외한 패킷들은 대기해야합니다.
- 모든 패킷이 하나의 버스를 건나가야해서, 라우터 교환 속도는 버스 속도에 의해 결정 됩니다.

### 상호연결 네트워크를 통한 교환

<img src="4_8.png" width="500">

- 크로스바 스위치는 N개의 입력포트를 N개의 출력 포트에 연결하는 2N 버스로 구성된 상호 연결 네트워크입니다.
- 각 수직 버스는 교차점에서 각 수평 버스와 교차하며 스위치 구조 컨트롤러에 의해 열거나 닫을 수 있습니다.
- 메모리 교환, 버스 교환 방식과 달리 크로스바 스위치는 여러 패킷을 병렬로 전달할 수 있습니다.
- 크로스바 스위치 출력 포트로 전달되는 패킷을 다른 패킷이 현재 해당되는 출력 포트로 전달되지 않는 한 해당 출력 포트에 도달하는 것을 차단하지 않습니다.
- 두개의 서로 다른 입력 포트에서 나오는 2개의 패킷이 동일한 출력 포트로 보내지는 경우 한번에 하나의 패킷만 특정 버스에서 전송될 수 있기 때문에 입력을 기다려야 합니다.
- 더 정교한 상호연결 네트워크는 다단계 스위치 구조를 통해, 각기 다른 입력 포트의 패킷이 동일한 출력 포트를 향해 전달할 수 있도록 여러 단계의 스위칭 요소를 사용합니다.

### 4.2.3 출력 포트 처리

- 출력 포트의 메모리에 저장된 패킷을 가져와서 출력 링크를 통해 전송한다. 전송을 위한 패킷 선택 및 큐 제거, 필요한 링크 계층 및 물리 계층 전송 기능을 수행하는 것이 포함된다.

### 4.2.4 어디에서 큐잉이 일어날까?

<img src="4_9.png" width="500">

- 패킷 큐는 입력 포트와 출력 포트 모두에서 형성될 수 있습니다.
- 큐의 위치와 범위는 트래픽 로드, 스위치 구조의 상대 속도 및 라인 속도에 따라 결정됩니다.
- 큐가 더 커지면 라우터의 메모리가 소모될 수 있고, 도착하는 패킷을 저장할 수 있는 메모리가 없게되면 패킷 손실을 발생하게 됩니다.

#### 입력 큐잉

- 지연 없이 구조를 통해 도착하는 모든 패킷을 전송하기에 스위치 구조가 충분히 빠르지 않으면 어떻게 될까?
- 이런 경우에는 패킷이 스위치 구조를 통해 출력 포트로 전송 되기위해 차례를 기다려야합니다.
- 큐잉의 중요한 결과를 살펴보기 위해 크로스바 스위치 구조를 가정해보겠습니다.
  1.  모든 링크의 속도가 같다.
  2.  입력 링크가 패킷을 받은 것과 같은 속도로 하나의 패킷을 입력 포트에서 주어진 출력 포트로 전달합니다.
  3.  FCFS 방식으로 패킷은 입력 큐에서 출력 큐로 이동합니다.
- 출력 포트가 다르다면 여러 패킷이 병렬로 전달될 수 있지만, 두 패킷이 같은 출력 큐로 향한다면 이 중 패킷은 차단되고 입력 큐에서 기다려야합니다.

<img src="4_10.png" width="500">

- 입력 큐 앞쪽에 있는 2개의 패킷이 동일한 오른쪽 상단의 출력 포트로 보내지는 그림입니다.
- 스위치 구조가 왼쪽 상단 큐의 앞쪽에서 패킷을 전송한다고 가정합니다.
- 왼쪽 상단 큐 앞쪽 패킷이 전송될 때 왼쪽 하단 큐에 짙은 색으로 처리된 두 번째 패킷은 대기 해야합니다.
- 아래쪽 밝은 패킷은 이동하려는 출력 링크가 없는 상태이지만 바로 앞의 검정 패킷 때문에 기달여야합니다.
- 이 현상은 입력 대기 중인 스위치에서의 HOL(head-of-the-line) 차단이라고 합니다.
- 라인 앞쪽에서 다른 패킷이 막고 있어, 입력 큐에서 대기 중인 패킷은 사용할 출력 포트가 사용중이지 않아도 스위치 구조를 통해 전송을 기다리게 됩니다.
- 입력 링크에 패킷 도착 속도가 용량의 58%가 되면 HOL 차단 떄문에 입력 큐가 무한정 길이 증가를 보여주며, 즉 패킷 손실이 증가합니다.

#### 출력 큐잉

- 스위치의 출력 포트에서 어떻게 큐잉이 발생할까요?
- R스위치가 R-line보다 N배 빠르며 N개의 입력 포트 각각 도착하는 패킷이 동일한 출력 포트로 항햐는 것을 가정합니다.
- 이 경우 출력 링크에 단일 패킷을 보내는 데 걸리는 시간에 N개의 새로운 패킷이 출력 포트에 도착합니다.
- 출력 포트는 시간 단위에 단일 패킷만 전송할 수 있기 때문에, N개의 도착 패킷은 출력 링크를 통한 전송 큐에 대기해야합니다.
- 그렇게 되면 N개의 패킷 중 하나를 전송할 때 새로운 N개의 패킷이 도착합니다.
- 스위치 구조가 포트 라인 속도보다 N배 빠른 경우 패킷 큐잉이 출력 포트에서 발생할 수 있습니다.

- 이때 패킷을 저장할 메모리가 충분하지 않을 때, 도착한 패킷을 삭제하거나 대기중인 패킷을 제거해 새로 도착한 패킷을 저장하기 위한 공간을 확보합니다.

<img src="4_11.png" width="500">

- 위 그림에서 출력 포트에 전송되어 대기중인 3개의 패킷이 있습니다.
- 3개의 패킷 중 하나는 다음 번 출력 라인에 전송이 될것이고,
- 2개의 새로운 패킷의 둘 중 하난느 출력 포트로 전송되게 됩니다.
- 이러한 큐잉의 결과는 출력 포트의 패킷 스케줄러가 전송 대기 중인 패킷 중 하나의 패킷을 선택하여 큐에서 제거 해야한다는 것이다.

#### 얼마나 많은 버퍼가 요구 되는가?

- 버퍼링이 클수록 라우터가 패킷 도착 속도의 큰 변동을 흡수하여 라우터의 패킷 손실률을 감소 시킬 수 있기 때문에 버퍼링이 낫다고 생각하는 것보다 버퍼가 클수록 큐잉 지연이 길어진다고 생각하는 편이 좋습니다.
- 패킷 손실을 줄이기 위해 버퍼 양을 10배 늘리면, 종단 간 지연이 10배만큼 증가하게됩니다.
- 즉, 버퍼의 크기 증가는 패킷 손실율을 줄일 수 있지만 종단 간 지연을 증가시킬 수 있는 양날의 검입니다.

### 4.2.5 패킷 스케줄링

- 큐에 있는 패킷이 출력 링크를 통해 전송되는 순서를 어떻게 결정하는지 알아보겠습니다.

1. FIFO (first_in_fist_out)
   <img src="4_12.png" width="500">

- 링크(서버)가 현재 다른 패킷을 전송중이면, 출력 링크 큐에 도착한 패캣들은 위 그림과 같이 대기 영역에서 전송을 기다립니다.
- 패킷이 출력되는 링크를 통해 완전히 전송되면 큐에서 제거됩니다.
- FIFO 또는 FCFS 스케줄링 규칙은 출력 큐에 도착한 순서와 동일한 순서로 출력 링크에서 패킷을 전송합니다.
- 위 그림처럼 1,2,3번의 패킷이 들어오면 패킷마다 전송하는데 소모되는 시간 간격만큼 간격을두고 1, 2, 3 순서대로 전송하게 됩니다.

2. 우선순위 큐잉
   <img src="4_13.png" width="500">

- 출력 링크에 도착핸 패킷은, 위 그림과 같이 우선순위 클래스로 분류됩니다.
- 실제 네트워크 오퍼레이터는 네트워크 관리 정보를 운반하는 패킷이 사용자 트래픽보다 우선순위를 수신하도록 큐를 구성할 수 있습니다.
- 전송할 패킷을 선택할 때 우선순위 큐는 전송 대기중인 패킷으로 차 있는 상태에고, 가장 높은 우선순위 클래스에서 패킷을 전송합니다.
- 우선 순위가 동일한 패킷들 중에서 FIFO 방식으로, 먼저들어온 패킷을 전송합니다.
- 위 그림에 1, 2, 3번 패킷이 들어왔을 때 1번과 3번은 우선순위가 높기 때문에 1, 3이 먼저 전송된 후 우선순위가 낮은 2번이 전송됩니다.

3. 라운드 로빈과 WFQ

- 라운드 로빈 큐잉 규칙에서 패킷은 우선순위 큐잉과 같이 클래스를 분류합니다.
- 클래스 간의 우선순위는 존재하지 않으며, 라운드 로빈 스케줄러가 클래스 간에 서비스를 번갈아서 제공합니다.
- 1번 클래스에서 패킷하나를 전송 후, 2번 클래스에서 패킷 전송, 3번 클래스에서 패킷 전송 방식으로 전송합니다.
- 작업 보존 큐잉 규칙의 경우, 전송을 위해 큐에서 기다리는 패킷이 있다면 링크는 유휴 상태가 되는 것을 허용하지 않습니다. 즉, 클래스에 패킷이 없때, 다음 클래스를 즉시 검사합니다.
  <img src="4_15.png" width="500">
- 위 그림은 2개의 클래스 라운드 로빈 큐 작동을 보여줍니다.
- 클래스 1에는 1, 2, 4 이 속하며 클래스 2에는 3,5이 속합니다.
- 1, 2, 3 번의 패킷이 도착했을 때, 클래스 1번의 1이 전송된후, 클래스 2번의 3번이 전송됩니다.
- 그후 클래스 1의 2번이 전송됩니다.

   <img src="4_14.png" width="500">

- 라우터에서 널리 구현된 라운드 로빈 큐잉의 일반화된 형태는 소위 WFQ(Weighted Fair Queueing) 규칙입니다.
- 도착한 패킷은 적절한 클래스별 대기 영역에 분류되며 대기합니다.
- 라운드 로빈 스케줄링처럼 WFQ 스케줄러는 순환 빙식으로 동작합니다.
- 작업 보존 큐잉 규칙을 따르며, 클래스가 비었을 경우 다음 클래스로 즉시 이동합니다.
