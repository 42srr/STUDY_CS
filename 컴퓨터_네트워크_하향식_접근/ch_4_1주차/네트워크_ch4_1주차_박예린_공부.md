# 4.1 네트워크 계층 개요
- 종단 시스템 H1에서 종단 시스템 H2로 정보가 보내진다고 가정했을 때, 중간에 있는 중계 라우터에 주목
- 라우터의 데이터 평면과 제어 평면은 서로 다른 역할을 하여, 정보가 잘 전달되도록 함
    - 데이터 평면 : 라우터의 입력 링크에서 출력 링크로 데이터그램을 잘 전달
    - 제어 평면 : 데이터그램이 출발지 호스트에서 목적지 호스트까지 잘 전달되게끔 로컬 포워딩, 라우터별 포워딩을 대응시킴

## 4.1.1 포워딩과 라우팅: 데이터 평면과 제어 평면

##### 포워딩(전달)
- 라우터의 한 입력링크에 도달한 패킷을 적절한 출력 링크로 이동시키는 것
- 매우 짧은 시간 단위(나노초)
- 하드웨어에서 실행
- 포워딩 테이블 (forwarding table)
    - 패킷 헤더의 필드값과 출력 링크 인터페이스가 짝지어져 있음
    - 필드값 조사 후 맞는 출력 링크로 보냄

##### 라우팅
- 네트워크 전반에 걸쳐 출발지에서 목적지까지 데이터그램의 종단 간 경로를 결정
- 라우팅 알고리즘 (routing algorithm)
    - 경로 계산 알고리즘
- 포워딩보다 상대적으로 긴 시간 단위를 가짐(초)
- 소프트웨어에서 실행 

##### 전통적인 접근 방법에서의 제어 평면
- 독립적이고 자율적인 방식 
    => 각 라우터가 포워딩 테이블 결정
    => 개별 라우터가 한번 정하면 끝나는 것이 아니라, 라우터끼리 상호작용하며 포워딩 테이블을 변경시키기도 함 

** 라우팅과 포워딩은 상관없는 것이 아니고, 서로 중요한 상호작용을 함
** 라우터는 포워딩과 라우팅 2개의 기능을 모두 가지고 있어야 함

##### SDN 접근 방법에서의 제어 평면 
- 중앙 집중적인 방식
    => 원격 컨트롤러(라우터로부터 물리적으로 분리)가 각각의 라우터에게 포워딩 테이블을 분배
- 라우터와 원격 컨트롤러 간의 소통
    - 메시지를 교환하며 소통 (ex. 포워딩 테이블, 그 밖의 라우팅 정보)
- 원격 컨트롤러 (: 포워딩 테이블 계산)
    => 소프트웨어어에서 실행 (라우터와 상호작용 함)

## 4.1.2 네트워크 서비스 모델
- 네트워크 서비스 모델에 따라 답이 달라지는 많은 질문들
    - 송신 호스트의 트랜스포트 계층이 패킷을 네트워크에 보낼 때 트랜스포트 계층은 네트워크 계층이 목적지까지 패킷을 전달한다는 것을 믿을 수 있는가?
    - 여러 패킷이 전송될 때, 보낸 순서와 동일하게 수신 호스트의 트랜스포트 계층에 전달될 수 있는가?
    - 연속적인 두 패킷 사이의 송신 시간이 이들 패킷의 수신 시 걸리는 시간과 동일한가?
    - 네트워크가 네트워크 혼잡에 대한 피드백을 제공할 수 있는가?
    - 송신 호스트와 수신 호스트에서 트랜스포트 계층을 연결하는 채널의 추상적인 관점은 무엇인가? 

- 네트워크 계층에서 제공할 수 있는 서비스
    - 보장된 전달
    - 지연 제한 이내의 보장된 전달
    - 순서화 패킷 전달
    - 최소 대역폭 보장
    - 보안 서비스 

- 인터넷 네트워크 계층이 제공하는 서비스 : 최선형 서비스 (best effort service)
    - 패킷을 보내는 순서대로 수신됨을 보장하지 ❌
    - 목적지까지의 전송 자체도 보장하지 ❌
    - 종단 시스템 간 지연 또한 보장하지 ❌

- ATM 네트워크 구조
    - 순서화 패킷 전달 ⭕
    - 지연 제한 이내의 보장된 전달 ⭕
    - 최소 대역폭 보장 ⭕

=> BUT 비싼 비용, 별로인 확장성 때문에 인터넷처럼 큰 규모에선 쓰이지 X 

- Intserv 구조
    - 종단 간 지연 보장 ⭕
    - 혼잡 방지 통신을 목표로 함

- 다른 구조가 있음에도, 그럭저럭 충분히 좋기 때문에 최선형 서비스가 채택됨 ⭕

##### 포워딩 VS 스위칭 
- 포워딩 
    - 들어온 패킷을 적절한 인터페이스(포트)로 내보내는 과정
    - 장비 : 라우터
- 스위칭
    - 들어온 프레임을 목적지로 보내는 과정
    - 장비 : 스위치 

## 4.2 라우터 내부에는 무엇이 있을까?

- 라우터의 4가지 요소 : 입력 포트, 스위치 구조, 출력 포트, 라우팅 프로세서

- (1) 입력 포트
    - 패킷 수신
    - 물리 계층 기능 수행
    - 링크 계층 기능 수행
    - 검색 기능 수행
        => 포워딩 테이블 조회
        => 패킷이 어느 출력 포트로 가야할지 결정
    - 큐잉 
- (2) 스위치 구조
    - 입력 포트에서 들어온 패킷을 적절한 출력 포트로 보내주는 내부 네트워크
- (3) 출력 포트
    - 라우터의 출구
    - 물리 계층 전송 => 전기 신호, 광신호로 변환해서 내보냄
    - 패킷 큐잉, 패킷 스케쥴링 
- (4) 라우팅 프로세서
    - 제어 평면 기능 수행
        - 라우팅 알고리즘 실행
        - 포워딩 테이블 관리
        - 네트워크 상태 모니터링 및 관리 
    - SDN에서는 원격 컨트롤러와 통신

##### 목적지 기반 포워딩 VS 일반화된 포워딩
- 목적지 기반 포워딩 : 포워딩 테이블만 조회해서 어디로 보낼지 결정
- 일반화된 포워딩 : 포워딩 테이블 + 다양한 고려 요인(ex. 출발지, 프로토콜 등) 함께 고려해서 어디로 보낼지 결정

### 4.2.1 입력 포트 처리 및 목적지 기반 전송

- 라인 종단 : 전기신호/광신호를 디지텔 데이터로 변환
- 데이터 링크 처리 : mac 주소 조회
- 목적지 주소의 프리픽스(PREFIX)를 토대로 링크 인터페이스 결정
- 최장 프리픽스 매치 규칙
    - 매칭되는 프리픽스가 여러 개 있다면, 가장 긴 경우를 채택
- 검색을 통해 출력 포트가 결정되면 패킷을 스위치 그조로 보낼 수 있음

### 4.2.2 스위칭
- 3가지 스위칭 기술 : 메모리, 상호연결 네트워크, 버스
- (1) 메모리
    - 입력 포트와 출력 포트는 전통적인 I/O 장치처럼 작동
    - 패킷이 들어오면 입력포트에서 해당 패킷을 버퍼에 복사, 후에 출력 포트의 버퍼에 복사 
- (2) 버스
    - 입력 포트는 라우팅 프로세스의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷 전송
    - 모든 출력 포트에 패킷이 수신되지만, 레이블과 매치되는 포트만 패킷 유지
    - 한번에 하나의 패킷만 버스 통과 가능
    - 하나를 제외한 모든 패킷은 대기해야 함
    - 라우터의 교환 속도는 버스 속도에 의해 제한됨
- (3) 상호연결 네트워크
    - 크로스바 스위치
        - 2N 버스로 구성된 상호연결 네트워크(N개의 입력포트를 N개의 출력 포트에 연결)
        - 각 수직 버스는 교차점에서 각 수평버스와 교차 

### 4.2.3 출력 포트 처리
- 출력 포트의 메모리에 저장된 패킷을 가져와서 출력 링크를 통해 전송

### 4.2.4 어디서 큐잉이 일어날까? 

##### 입력 큐잉
- 출력 포트가 다르다면 여러 패킷이 병렬로 전달될 수 있지만, 두 패킷이 같은 출력 큐로 향한다면 이 중 한 패킷은 차단되고 입력 큐에서 기다려야 함

- HOL 차단 (head of the line)
    - 라인의 앞쪽에서 다른 패킷이 막고 있으면, 큐에서 대기중인 뒤에 있는 패킷은 사용할 출력 포트가 사용중이지 않아도(= 앞에 있는 패킷과 목적 출력 포트가 다르더라도) 기다려야 함

##### 출력 큐잉
- 출력 포트는 시간 단위에 단일 패킷만을 전송할 수 있음
- 전송 큐에서 대기 필요
- 들어오는 패킷을 저장할 메모리가 충분하지 않을 때 도착한 패킷을 삭제하거나 대기중인 패킷을 삭제해야 함
- 패킷 스케줄러가 패킷을 선택

##### 얼마나 많은 버퍼가 요구되는가?
- 규칙 1: 버퍼링의 양은 평균 왕복시간과 같아야 함 
    ex. 평균 왕복시간이 250ms인 10Gbps 링크는 RTT * C(링크용량) = 2.5Gb과 같은 버퍼양 필요
- 규칙 2: RTT * C / sqrt(N)
    - 많은 수의 독립적인 TCP 흐름(N)이 링크를 통과할 때
- 규칙 2가 좀 더 최근의 이론과 실험 결과
- 버퍼링일 클수록 큐잉 지연이 길어짐
- 버퍼블로트(bufferbloat)
    - 지속적 버퍼링으로 인한 긴 지연에 대한 시나리오 
    - 종단 간 파이프는 꽉 찼지만 큐잉 지연의 양은 일정하고 지속적이라 다른 트래픽이 네트워크에 존재하지 않아도 지연이 지속적으로 김

### 4.2.5 패킷 스케쥴링
- 큐에 있는 패킷이 전송되는 순서를 결정해야 하는데, HOW?

##### FIFO
- 링크 큐에 도착한 순서와 동일한 순서로 출력 링크에서 전송할 패킷 선택
##### 우선순위 큐잉
- 운선순위 클래스로 따로 분류, 따로 큐가 있음
- 가장 높은 우선순위 클래스에서 패킷 전송 
- 그 안에서는 FIFO로 선택 

##### 라운드 로빈과 WFQ
- 클래스로 패킷 구분
- 클래스 간에는 엄격한 우선순위가 존재하지 않고, 번갈아서 제공
- 라운드 로빈
    - 클래스 1 - 클래스 2 -클래스 1 -클래스 2
- 작업 보존 큐잉 
    - 빈 클래스 큐를 찾으면 서비스 순서에서 다음 클래스로 즉시 이동 
    