---
id: "[42GGS-Study] 컴퓨터 네트워킹 - 2주차"
aliases:
  - "[42GGS-Study] 컴퓨터 네트워킹 - 2주차"
tags:
  - 42GGS
  - CS
  - Study
  - Network
---

# [42GGS-Study] 컴퓨터 네트워킹 - 2주차

## Chapter 02. 애플리케이션 계층 (1)

>
> 네트워크 애플리케이션의 개념 & 구현
>

### 2.1 네트워크 애플리케이션의 원리

- `네트워크 애플리케이션` : **다른 위치의 종단 시스템에서 동작하고 네트워크를 통해 서로 통신하는 프로그램**. (ex. `서버(웹 서버 프로그램)`와 `클라이언트(사용자 호스트에서 실행되는 브라우저 프로그램)`)

#### 2.1.1 네트워크 애플리케이션 구조

- `애플리케이션 구조`와 `네트워크 구조(1장의 5단계 네트워크 아키텍쳐)`는 다름.
- 애플리케이션 개발자 관점에서 `네트워크 구조`는 고정되어 있으며, 네트워크는 애플리케이션에 특정 서비스 집합을 제공함. `애플리케이션 구조`는 개발자가 직접 설계하며, 애플리케이션이 다양한 종단 시스템에서 어떻게 조직되어야 하는지 알려줌.
- 현대 애플리케이션 구조로 잘 알려진 2가지 : `클라이언트-서버(client-server)`, `P2P`

<p align="center">
	<img width="700" alt="애플리케이션 구조" src="https://user-images.githubusercontent.com/76640167/210484607-f2096b44-08ec-4e8d-b75d-4e3df863f35d.png" />
</p>

##### 클라이언트-서버(client-server) 구조

- **항상 동작하고 있는 서버가 존재**. 서버는 **잘 알려진 고정 IP 주소**를 갖는다.
- `서버`는 `클라이언트`라는 다른 호스트들로부터 서비스 요청을 받으며, 클라이언트는 서로 직접적으로 통신하지 않는다.
- 클라이언트로부터 오는 요청의 개수가 서버의 처리 능력을 상회하는 하는 경우, 모든 요청을 처리할 수 없다.
- 이를 해결하기 위해 강력한 가상 서버를 생성하는 데이터 센터가 존재한다. 데이터 센터는 보통 10만개 정도의 호스트(서버)를 갖추고 있다. 잘 알려진 구글, 아마존 등의 경우 하나 이상의 데이터 센터에서 운영된다.

##### P2P 구조

- 항상 켜져있는 인프라스트럭처 서버가 필요하지 않거나, 적은 수만 필요.
- 애플리케이션은 `peer`라는 **간헐적으로 연결된 호스트쌍이 서로 직접 통신**.
- `peer`는 서비스 제공자가 소유하지 않고 사용자들이 제어하는 데스크톱, 랩톱이다.
- **자가 확장성**을 가진다. 예를 들어, 파일 공유 애플리케이션에서는 각 피어들이 파일을 요구하여 작업 부하가 생기지만 각 피어들은 파일을 다른 피어들에게 분배하여 시스템에 서비스 능력을 갖춘다.
- 데이터 센터 등이 필요 없으므로 비용 효율적.


#### 2.1.2 프로세스 간 통신

- 실제 통신하는 것은 프로그램이 아니라, 실행되고 있는 프로그램인 **프로세스**.
- 2개의 종단 시스템에서 프로세스는 **컴퓨터 네트워크를 통한 메시지 교환**으로 서로 통신.

##### 클라이언트와 서버 프로세스

- `클라이언트(client)` : **통신을 초기화(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스**
- `서버(server)` : **세션을 시작하기 위해 접속을 기다리는 프로세스**

##### 프로세스와 컴퓨터 네트워크 사이의 인터페이스

<p align="center">
	<img width="700" alt="소켓" src="https://user-images.githubusercontent.com/76640167/210484602-4feb26bd-c1bf-43dd-aa19-14fcac26b146.png" />
</p>

- 프로세스는 `소켓(socket)`을 통해 메세지 교환.
- `소켓`은 **호스트의 애플리케이션 계층과 트랜스포트 계층간의 인터페이스**
- 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스이므로, **애플리케이션과 네트워크 사이의 API**라고도 함.

- 애플리케이션 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖지만, 소켓의 트랜스포트 계층에 대한 통제권은 거의 갖지 못함.
- 애플리케이션 개발자가 가지는 트랜스포트 계층 관련 통제권
    1. 트랜스포트 프로토콜의 선택
    2. 최대 버퍼와 최대 세크먼트 크기 같은 약간의 매개변수 설정

##### 프로세스 주소 배정

- 네트워크 상에서 메세지 교환을 송신 프로세스는 수신 프로세스에 대한 정보 필요.
- 수신 프로세스 식별을 위해 필요한 정보
    1. 호스트 주소(**IP 주소**)
    2. 목적지 호스트 내의 수신 프로세스를 명시하는 식별자(**port 번호**; ex. 웹서버(80), SMTP(25))


#### 2.1.3 애플리케이션이 이용 가능한 트랜스포트 서비스

- 소켓은 애플리케이션 프로세스와 트랜스포트 프로토콜 간 인터페이스
- 송신 측의 애플리케이션은 소켓을 통해 메시지 전송
- 트랜스포트 프로토콜은 송신 측 소켓에서 전달받은 내용을 네트워크를 통해 수신 프로세스 소켓으로 전송

- **트랜스포트 프로토콜이 제공하는 4가지 서비스**
    - 신뢰적 데이터 전송(data integrity)
    - 처리율(throughput)
    - 시간(timing)
    - 보안(security)

##### 신뢰적 데이터 전송(data integrity)

- 데이터가 전송 과정에서 손실되거나, 훼손되지 않고 올바르게 전송되는 것을 보장
- 송신 프로세스, 수신 프로세스는 데이터가 오류 없이 전송되었다는 확신을 가질 수 있음
- 만약, 이 서비스가 제공되지 않을 경우 송신 프로세스가 전송한 데이터가 전달되지 않을 수 있음.  (ex. UDP 사용 스트리밍 서비스. `손실 허용 애플리케이션(loss-tolerant application)`)

##### 처리율(throughput)

- (1장) 두 프로세스 간 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율
- 세션들은 네트워크 대역폭을 공유하고, 필요에 의해 생성, 소멸되므로 가용 처리율은 실시간으로 변동
- 트랜스포트 프로토콜은 필요에 따라 애플리케이션에 명시된 속도로  보장된 가용 처리율 제공 가능.
- `대역폭 민감 애플리케이션(bandwidth-sensitive application)` 에서 중요함.
- `탄력적 애플리케이션(elastic application)` 에서는 상대적으로 덜 중요함.라고 한다.

##### 시간(timing)

- 송신자가 소켓으로 보내는 모든 비트가 수신자의 소켓에 특정 시간(ex. 100ms) 내에 도착하도록 보장하는 등 여러 가지 형태로 시간 보장(timing guarantee) 제공
- 인터넷 전화, 가상 환경, 원격회의, 멀티플레이 게임 같은 실시간 상호작용 애플리케이션에 필요

##### 보안(security)

- `기밀성(confidentiality)`, `데이터 무결성(integrity)`, `종단 인증(authentication)` 등과 같은 서비스 제공 가능


#### 2.1.4 인터넷 전송 프로토콜이 제공하는 서비스

>
> `TCP(Transmission Control Protocol)`, `UDP(User Datagram Protocol)`
>

##### TCP 서비스

- 연결 지향형
  : `핸드셰이킹(handshaking)` 을 통해 메세지 전송 전에 클라이언트-서버 간 전송 제어 정보 교환하고 메세지 전송 준비를 마침. 서로 동시 메세지 전송이 가능하므로 `전이중 연결(full-duplex)`이라고 함. 전송을 마치면 연결을 끊는 과정 진행.

- 신뢰적인 데이터 전송
  : **모든 데이터를 오류 없이 올바른 순서로 전달**

- 혼잡 제어 방식 제공
  : 통신 프로세스의 직접 이득보다는 인터넷 전체 성능 향상을 위한 서비스. 네트워크 대역폭을 공평하게 공유할 수 있도록 제한.

##### UDP 서비스

- 최소 서비스 모델을 가진 간단한 전송 프로토콜
- **비연결형**(핸드셰이킹 과정 X)
- **비신뢰적인 데이터 전송 서비스** (데이터 전달 보장 X, 데이터 순서 보장 X)
- **혼잡 제어 방식 포함 X** (송신 측이 원하는 속도로 송신 가능 but 혼잡으로 인한 종단 간 처리율 감소로 전송 속도가 더 낮아질 수 있음)

##### 인터넷 트랜스포트 프로토콜이 제공하지 않는 서비스

- `TCP`, `UDP` 처리율 혹은 시간 보장 서비스 미제공.
- `시간 민감 애플리케이션` 같은 경우에는 처리율 및 시간 지연에 잘 대처할 수 있도록 설계됨. 그러나 지연이 과도할 때는 보장이 없기 때문에 한계가 있다.


#### 2.1.5 애플리케이션 계층 프로토콜

>
> 💡 `애플리케이션 계층 프로토콜` 서로 다른 종단 시스템 상의 **애플리케이션 프로세스 간 메세지 교환 방법 정의**
>
>  - 교환 메시지의 `타입`
>  - 여러 메시지 타입의 `문법(syntax)`
>  - 필드의 의미, 즉 필드에 있는 정보의 `의미(semantics)`
>  - 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지를 결정하는 `규칙`
>

- 애플리케이션 계층 프로토콜 : `RFC`에 명시된 일부는 공개되어 있음. 다른 많은 애플리케이션 계층 프로토콜은 독점이며 비공개.

- 애플리케이션 계층 프로토콜은 네트워크 애플리케이션의 **한 요소**. 예를 들어, 웹 애플리케이션은 문서 포맷 표준, 웹 브라우저, 웹 서버, 웹 애플리케이션 계층 프로토콜(HTTP)을 포함하는 여러 요소들로 구성된다. 만약 브라우저 개발자가 HTTP 규칙을 따른다면, HTTP 규칙을 따른 어떠한 웹 서버로부터도 웹페이지를 가져올 수 있다.


#### 2.1.6 이 책에서 다루는 네트워크 애플리케이션

- 웹
- 전자메일
- 디렉터리 서비스
- 비디오 스트리밍
- P2P 애플리케이션


### 2.2 웹과 HTTP

>
> 1990년대 초반 `www(World Wide Web)` 등장. `온디맨드(on-demand) 방식`을 포함한 여러 특성으로 널리 퍼짐
>

#### 2.2.1 HTTP (Hypertext Transfer Protocol) 개요

- `웹 애플리케이션 계층 프로토콜`. `RFC 1945`, `RFC 7230`, `RFC 7540`에 정의.

- `웹 페이지(web page)`들은 `객체(object)`로 구성.
- `객체(object)`는 단순히 단일 URL로 지정할 수 있는 하나의 파일(HTML, JPEG 이미지, 자바스크립트 등).
- 대부분의 웹 페이지는 `기본 HTML 파일`과 `여러 참조 객체`로 구성된다. 예를 들어, 웹 페이지가 HTML 텍스트와 5개의 JPEG 이미지로 구성되어 있으면, 이 웹페이지는 6개의 객체를 갖는다.
- 기본 HTML 파일은 페이지 내부의 다른 객체를 그 객체의 `URL`로 참조. `URL`은 `객체를 갖고 있는 서버의 호스트 이름`과 `객체의 경로 이름`을 가짐.
- ex.
  ```
  http://www.school.edu/picture.gif 
  ```
  - 호스트의 이름 : `www.school.edu`
  - 경로 이름 : `picture.gif`

- `웹 브라우저(Web browser)`
 : HTTP의 클라이언트 구현체. 웹의 관점에서 브라우저와 `클라이언트(client)`는 혼용하여 사용. 요구한 웹 페이지를 보여주고 여러가지 인터넷 항해와 구성 특성을 제공.

- `웹 서버(Web server)`
 : URL로 각각을 지정할 수 있는 웹 객체를 저장하고 있음.

- 일반적으로, 사용자의 웹 페이지 요청시
  1. `브라우저` : `서버`에 페이지 내부 객체에 대한 `HTTP 요청 메세지` 전송.
  2. `서버` : 요청 수신후 객체를 포함하는 `HTTP 응답 메시지` 전송.

- `HTTP`의 전송 프로토콜은 `TCP`. (올바른 데이터 & 올바른 순서로 전송)
  1. `HTTP 클라이언트`가 먼저 서버로 `TCP 연결` 시작.
  2. `핸드셰이킹` 후 `브라우저`, `서버`는 각각의 `소켓 인터페이스`에 접속.
  3. `HTTP 요청 메시지`(클라이언트), `HTTP 응답 메시지`(서버)를 주고 받음.  

- `HTTP` = `stateless protocol`
 : `서버`는 `클라이언트`에 대한 정보를 유지하지 않음.예를 들어, 특정 클라이언트가 몇 초 후에 같은 객체를 두 번 요청해도 서버는 전에 보냈다고 알려주지 않고 객체를 다시 전송.

- ***HTTP는 통신 프로토콜만 정의할 뿐, 웹 페이지(객체)에 대한 관심 X.***
- HTTP의 디폴트 모드 : 지속 연결(파이프라이닝 이용)

#### 2.2.2 비지속 연결과 지속 연결

- `비지속(non-persistent) 연결`
  HTTP 메세지 전송 과정에서 각각의 요청/응답이 ***분리된 TCP 연결***을 통해 전송.

- `지속(persistent) 연결`
  HTTP 메세지 전송 과정에서 각각의 요청/응답이 ***같은 TCP 연결***을 통해 전송.

##### 비지속(non-persistent) 연결 (HTTP/1.0)

-  서버에서 클라이언트로 웹 페이지를 전송하는 과정

>
> 페이지는 **기본 HTML 파일, 10개의 이미지**로 구성. 모든 객체가 같은 서버에 존재한다고 가정.
>

  1. HTTP 클라이언트는 `HTTP 기본 포트 80`을 통해 서버로 `TCP 연결` 시도. TCP 연결과 관련하여 클라이언트와 서버에 각각 `소켓` 생성.
  2. `HTTP 클라이언트` : `TCP 연결 소켓`을 통해 서버로 `HTTP 요청 메시지` 전송. 이 요청에 `객체 경로`도 포함.
  3. `HTTP 서버` : `TCP 연결 소켓`을 통해 `요청 메시지` 수신. `요청 메세지상의 객체 경로`를 참조하여 저장 장치로부터 객체 추출. `HTTP 응답 메시지`에 객체를 `캡슐화`하여 소켓을 통해 클라이언트로 전송.
  4. `HTTP 서버` : TCP에게 연결 해제 요청. (실제로 클라이언트가 응답 메시지를 올바로 받을 때까지 유지)
  5. HTTP 클라이언트가 응답 메시지를 받으면, TCP 연결 해제.
  6. `HTTP 클라이언트` : 응답 메시지로부터 파일을 추출하고 HTML 파일을 조사하여 10개의 JPEG 객체에 대한 참조를 찾는다.
  7. **참조되는 JPEG 객체에 대해 1 ~ 4단계를 반복한다.**

- 브라우저는 웹 페이지를 수신하면서, 사용자에게 그 페이지를 보여줌. 또한, **여러 개의 TCP 연결을 설정, 다중 연결상에서 웹 페이지의 각기 다른 원하는 부분 요청 가능**
- 사용자는 앞의 단계를 동시에 받을지 순차적으로 받을지의 동시성 정도를 조절할 수 있도록 브라우저 구성 가능.


- `RTT(round-trip-time)`
 : **패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간**. `RTT`는 패킷 전파 지연, 큐잉 지연, 처리 지연 등을 포함한다. (1장)

>
> 클라이언트가 HTML 파일을 요청하고 그 파일이 클라이언트로 수신될 때까지의 시간 측정.
>

<p align="center">
	<img width="600" alt="HTML 요청 시간 계산" src="https://user-images.githubusercontent.com/76640167/210491569-3638ca03-2d17-4eea-8a5f-d984bb831d00.png" />
</p>

- 사용자가 하이퍼링크를 클릭하면, 브라우저와 웹 서버 사이에서 TCP 연결 시도 (`3-way handshake` 포함)
- 서버가 작은 메시지로 응답하면 한 RTT가 계산됨. 이때, **클라이언트는 HTTP 요청 메시지를 TCP 연결로 보내면서 세 번째 응답 부분을 함께 보낸다.**
- 일단, 요청 메시지가 도착하면 서버는 HTML 파일을 TCP 연결로 보내고 이 요청은 또 하나의 RTT를 필요로 한다.

- `총 응답 시간` = `2RTT` +  `HTML 파일을 서버가 전송하는 데 걸리는 시간`


##### 지속(persistent) 연결 (HTTP/1.1)

- `비지속 연결의 단점`
  1. **각 요청 객체에 대한 새로운 연결 설정 및 유지 필요**. 클라이언트 요청이 많아질 경우 웹 서버 부담 증가.
  2. 매번 **2RTT** 필요 : `TCP 연결 설정 1RTT` + `객체 요청 및 수신 1RTT`

- `지속 연결`
  서버가 응답을 보낸 후에도 TCP 연결 유지.(`비지속 연결`도 지원함) **같은 클라이언트와 서버 간 요청/응답은 같은 연결을 통해 전송**. 즉, 같은 서버에 있는 여러 웹 페이지들을 하나의 지속 TCP 연결을 통해 전송 가능.

- `파이프라이닝(pipelining)`
  이전 객체 요청에 대한 응답을 기다리지 않고 연속해서 새로운 요청 생성 및 전송

- 연결이 일정 기간 사용되지 않으면 HTTP 서버는 연결을 해제함


#### 2.2.3 HTTP 메시지 포맷

- HTTP 명세 \[[RFC 1945](https://datatracker.ietf.org/doc/html/rfc1945), [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230), [RFC 7540](https://datatracker.ietf.org/doc/html/rfc7540)\] 에서 HTTP 메세지 포맷 정의

##### HTTP 요청 메시지

<p align="center">
	<img width="600" alt="요청 메시지 포맷" src="https://user-images.githubusercontent.com/76640167/210494014-891426d1-0c27-47dc-8271-c6f5bab316e9.png" />
</p>

```http
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

- HTTP 요청 메세지 특징
  1. ASCII 텍스트로 쓰여 있어 사람들이 읽을 수 있다.
  2. 메시지가 다섯 줄로 되어 있고, **각 줄은 CR(carriage return)과 LF(line feed)로 구별된다.** 마지막 줄에 이어서 CR과 LF가 따른다.
- HTTP 요청 메시지의 첫 줄은 `요청 라인`이라 부르고, 이후의 줄들은 `헤더 라인`이라고 부른다.


###### 요청 라인
```http
GET /somedir/page.html HTTP/1.1
```
  - `방식 필드` : `GET`, `POST`, `HEAD`, `PUT`, `DELETE` 등.
  - `URL 필드`
  - `HTTP 버전 필드`


###### 헤더 라인
```http
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```
  1. Host
    - 객체가 존재하는 호스트를 명시한다.
    - 이미 호스트까지 TCP 연결이 맺어져 있어 불필요하다고 생각될 수 있지만, 2.2.5절에서 나오는 웹 프록시 캐시에서 필요로 한다.
  2. Connection : 이 헤더 라인을 포함함으로써, 브라우저는 서버에게 지속 연결 사용을 원하는지 비지속 연결 사용을 원하는지 전달한다.
  3. User-agent : 서버에게 요청을 하는 브라우저 타입을 명시한다.
  4. Accept-language : 헤더는 사용자가 객체의 어떤 언어 버전을 원하고 있음을 나타낸다.


###### 개체 몸체(entity body)

- `POST` 일 때 사용(`GET`일 때는 비어있음).
- 사용자가 `POST` 메시지로 서버에 웹 페이지를 요청시 웹 페이지의 특정 내용은 사용자가 폼 필드에 입력한 내용에 따라 달라짐.
- 폼으로 생성한 요구가 반드시 `POST`일 필요는 없음. 대신에 흔히 요청된 URL의 입력 데이터를 전송한다.

---

- `HEAD`
  `GET`과 유사. **서버가 HEAD 방식을 가진 요청을 받으면 HTTP 메시지로 응답하는데, 요청 객체는 보내지 않는다.** 흔히 디버깅을 위해 사용

- `PUT`
  웹 서버에 업로드할 객체를 필요로 하는 애플리케이션에 의해 사용

- `DELETE`
  사용자 또는 애플리케이션이 웹 서버에 있는 객체를 지우는 것을 허용


##### HTTP 응답 메시지

<p align="center">
	<img width="600" alt="응답 메시지" src="https://user-images.githubusercontent.com/76640167/210497215-8265b94b-c82f-4ea8-9374-5f41fc6eaed1.png" />
</p>

```http
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data data data ...)
```

###### 상태 라인과 상태 코드

```http
HTTP/1.1 200 OK
```

- `상태 라인(status line)`
  - `버전 필드`
  - `상태 코드` & `상태 메시지`
    - `200 OK` : 요청이 성공했고, 정보가 응답으로 보내졌다.
    - `301 Moved Permanently` : 요청 객체가 영원히 이동되었다. 이때, 새로운 URL은 응답 메시지의 Location 헤더에 나와있다.
    - `400 Bad Request` : 서버가 요청을 이해할 수 없다.
    - `404 Not Found` : 요청한 문서가 서버에 존재하지 않는다.
    - `505 HTTP Version Not Supported` : 요청 HTTP 프로토콜 버전을 서버가 지원하지 않는다.


###### 헤더 라인

```http
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
```

- `Connection` : 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫을지 말지 결정한다.
- `Date` : HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타낸다.
- `Server` : 메시지가 어떤 웹 서버에 의해 만들어졌는지 나타낸다.
- `Last-Modified` : 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다.
- `Content-Length` : 송신되는 객체의 바이트 수를 나타낸다.
- `Content-Type` : 개체 몸체 내부(Entity body)의 객체가 어떤 타입인지 나타낸다.

- HTTP 명세서에 정의된 헤더의 일부임.
- `브라우저/웹서버` 는 브라우저 타입과 여러 설정, 캐싱 여부에 따라 헤더 라인을 동적으로 생성


#### 2.2.4 사용자와 서버 간의 상호 작용: 쿠키(cookie)

- HTTP 서버는 상태를 유지하지 않음.
- 때에 따라 서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 제공하기를 원하는 경우처럼 **사용자를 확인하는 것이 바람직할 때가 있는데, 이때 HTTP는 `쿠키(cookie)`를 사용한다.**

<p align="center">
	<img width="700" alt="쿠키를 이용한 상태 유지" src="https://user-images.githubusercontent.com/76640167/210499304-190c6dc5-ab64-4864-9f25-bb27fc63f460.png" />
</p>

- 쿠키 동작 과정
  1. 웹 서버에 HTTP 요청 메시지 전송.
  2. 웹 서버는 `식별 번호` 생성. 이 `식별 번호`로 인덱싱 되는 백엔드 데이터 베이스 안에 엔트리 생성.
  3. **HTTP 응답 메시지에** `Set-cookie: 식별 번호`의 헤더를 포함해서 전송.
  4. 브라우저는 헤더를 보고, 관리하는 특정한 쿠키 파일에 그 라인을 덧붙인다.
  5. 다시 **동일 웹 서버에 요청을 보낼 때** 브라우저는 쿠키 파일을 참조하고 이 사이트에 대한 식별번호를 발췌하여 `Cookie : 식별 번호`의 헤더를 요청과 함께 전송.


#### 2.2.5 웹 캐싱

>
> `웹 캐시(cache)`(`프록시(proxy) 서버`)는 기점 웹 서버를 대신하여 HTTP 요구를 충족시키는 개체이다.
>

- 자체 저장 디스크에 **최근 호출된 객체의 사본 저장 및 보존**

<p align="center">
	<img width="450" alt="웹 캐싱" src="https://user-images.githubusercontent.com/76640167/210502046-6dbbe817-240d-401d-8ec6-f3a73210e48d.png" />
</p>


- 프록시 서버 동작 과정
  1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.
  2. 웹 캐시는 객체의 사본이 저장되어 있는지 확인하고, **저장되어 있다면 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다.**
  3. **갖고 있지 않다면, 기점 서버로 TCP 연결을 설정한다.**  
     이후 웹 캐시는 캐시와 서버 간의 TCP 연결로 객체에 대한 HTTP 요청을 보낸다. 기점 서버는 웹 캐시로 HTTP 응답 메시지를 보낸다.
  4. 웹 캐시의 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지를 보낸다. (이때, 이미 설정된 TCP를 통해 보낸다.)

- 캐시(cache)는 요청과 응답을 모두 하는 클라이언트이면서 서버이다.
  - `server` for original requesting client
  - `client` to origin server
- 웹 캐시의 구입 및 설치는 일반적으로 ISP(university, company, residential ISP)가 진행

- 웹 캐싱의 사용 이유
  1. **클라이언트 요구에 대한 응답 시간을 줄일 수 있다.**  
     보통 클라이언트와 캐시 사이에 높은 속도의 연결이 설정되어 있어 웹서버 캐시에 객체를 갖고 있다면 병목 현상을 줄일 수 있다.
  2. 웹 캐시는 한 기관에서 인터넷으로의 접속하는 링크 상의 웹 트래픽을 대폭 줄일 수 있다.
  3. 인터넷 전체의 웹 트래픽을 실질적으로 줄여주어 모든 애플리케이션의 성능이 좋아진다.

---

##### 웹 캐시 사용 여부에 따른 성능 비교

###### 웹 캐시 미사용시

<p align="center">
	<img width="370" alt="병목 현상" src="https://user-images.githubusercontent.com/76640167/210504713-f02f053c-e503-413f-8cbc-046c55082359.png" />
</p>

- 평균 객체 크기 `1 Mb`, 브라우저로부터 서버에 대한 평균 요청 비율이 `초당 15개`라고 가정.
- HTTP 메시지 요청은 무시할만큼 작고, 네트워크 접속 회선에 어떤 트래픽도 발생시키지 않는다고 가정.
- 접속 회선 인터넷 부분 라우터가 **HTTP 요청 전달 및 응답 수신까지 `평균 2초`가 걸린다고 가정.(`인터넷 지연`)

$$
{총 응답 시간} = {LAN 지연} + {접속 지연} + {인터넷 지연}
$$

- LAN 트래픽 강도

$$
{15 _{req/sec}} \times \frac{1 _{Mb/req}}{100 _{Mbps}} = 0.15
$$

- 접속 회선 (라우터 ~ 라우터) 트래픽 강도

$$
{15 _{req/sec}} \times \frac{1 _{Mb/req}}{15 _{Mbps}} = 1
$$

- LAN의 트래픽 강도는 많아야 수십 ms의 지연을 야기하므로 LAN 지연을 무시할 수 있지만,  
트래픽 강도가 1에 가까워지면 1.4절에서 논의한 것과 같이 회선의 지연은 매우 커지고 한없이 증가.
- **접속 회선의 접속률을 100 Mbps 수준으로 늘리면 트래픽 강도를 0.15로 낮추어 해결할 수 있겠지만, 매우 많은 비용이 들어간다.**


###### 웹 캐시 사용시

<p align="center">
	<img width="370" alt="인터넷의 구성 요소" src="https://user-images.githubusercontent.com/76640167/210506730-5cb70fea-a9ed-4817-afe0-4463bfd24a4a.png" />
</p>

- 캐시 ~ 클라이언트는 고속 LAN으로 연결
- `캐시 적중률(hit rate)`은 `0.4`로 가정(일반적으로 `0.2 ~ 0.7`).
- 요청의 `40%`는 캐시에 의해(10ms 이내) 즉시 만족
- 나머지 `60%`의 요청은 여전히 기점 서버에 의해 만족되어야 함. 따라서 트래픽 강도는 1.0에서 0.6으로 감소한다.
- 일반적으로 `0.8 미만`의 트래픽 강도는 `작은 지연`에 속한다. (2초에 비하면 무시할 수 있는 수준)

- 평균 지연

$$
0.4 \times 0.01_{sec} + 0.6 \times 2.01_{sec} = 1.2....
$$

많은 캐시가 저렴한 PC에서 실행되는 공개 소프트웨어를 사용한다.
- 콘텐츠 전송 네트워크(CDN)을 통해 웹 캐시는 인터넷에서 점진적으로 중요한 역할을 하고 있다.
- CDN 회사는 인터넷 전역을 통해 많은 지역적으로 분산된 캐시를 설치하고 있으며,  
  이를 통해 많은 트래픽을 지역화하고 있다. (전용 CDN을 사용하기도 한다.)


##### 조건부(conditional) GET

- 웹 캐싱 사용시 사용자가 느끼는 응답 시간을 줄일 수 있지만, **웹 캐시 내부에 있는 복사본이 새 것이 아닐 수 있음**. 복사본이 클라이언트에 캐싱된 이후 웹 서버에 있는 객체가 갱신되었을 수도 있기 때문.

- `조건부 GET(conditional GET)`
  HTTP는 클라이언트가 **브라우저로 전달되는 모든 객체가 최신의 것임을 확인하면서 캐싱**하는 방식. HTTP 요청 메시지가 `(1) GET 방식을 사용`, `(2) If-modified-since 헤더` 포함하는 경우 `조건부 GET`

###### 조건부 GET 동작 과정

1. 브라우저의 요청을 대신해서 프록시 캐시는 요청 메시지를 웹 서버로 보낸다.

```http
GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
```

2. 웹 서버는 캐시에게 객체를 가진 응답 메시지를 보낸다.
    - 캐시는 요청하는 브라우저에게 객체를 보내주고 자신에게도 객체를 저장한다.
    - 중요한 것은 캐시가 객체와 더불어 **마지막으로 수정된 날짜를 함께 저장한다**는 것이다.

```http
HTTP/1.1 200 OK
Date: Sat, 3 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)
Last-Modified: Wed, 9 Sep 2015 09:23:24
Content-Type: image/gif
(data data data data data ...)
```

3. 일주일 후에 다른 브라우저가 같은 객체를 캐시에게 요청하면 캐시에 저장되어 있다. 이 객체는 지난주에 웹 서버에서 수정되었으므로, 브라우저는 `조건부 GET`으로 조사를 수행한다.
  - `If-modified-since` 값이 일주일 전에 서버가 보낸 Last-Modified 값과 완벽히 일치한다.
  - 이 조건부 GET은 서버에게 **If-modified-since에 명시된 값 이후 수정된 경우에만 그 객체를 보내라고 한다.**

```http
GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
If-modified-since: Wed, 9 Sep 2015 09:23:24
```

4. 변경되지 않았다면,
  - 아래와 같은 응답을 보낸다. 데이터가 변화가 없어도 객체를 보내는 것은 대역폭을 낭비하는 것이고, 특히 그 개체가 크다면 사용자가 느끼는 응답 시간이 증가된다.
  - 위 응답 메시지는 클라이언트에게 요청 객체의 캐싱된 복사본을 사용하라는 것을 의미한다.

```http
HTTP/1.1 304 Not Modified
Date: Sat, 10 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)
(empty entity body)
```


#### 2.2.6 HTTP/2

- `HTTP/2` 주요 목표 : <u>하나의 TCP 연결상에서 멀티플렉싱 요청/응답 지연 시간을 줄이는 것</u>
- `HTTP/2` 가 제공하는 주요 기능
  - 요청 우선순위화
  - 서버 푸시
  - HTTP 헤더 필드 압축
  - 데이터 포맷, 클라이언트 ~ 서버 간 전송 방법 변경

##### `HTTP/2` 의 필요성 (기존 `HTTP/1.1`에서의 TCP 관련 문제)

- `HTTP/1.1` 단일 TCP 연결을 유지하면서 웹 페이지를 전송하는 경우
  - 서버에서 필요한 소켓 수 감소
  - 각 웹 페이지가 공정한 네트워크 대역폭으로 전송 가능
- **but**  `HOL(Head of Line) Blocking` 발생 가능

###### HOL(Head of Line) Blocking

- 병목 링크가 존재하는 경우 크기가 큰 객체(예를 들어, 비디오 등)가 전송되는 동안 다른 객체들이 전송되지 못함
- `HTTP/1.1` 에서는 여러 개의 `병렬 TCP 연결`을 통해 해당 문제를 해결
  이 경우에 서버에서 필요한 소켓 수는 감소되지 않고 오히려 더 증가할 수 있고, 대역폭이 공평하게 분배되지 않음*

\* `TCP 혼잡 제어(TCP congestion control)` : n개의 TCP 연결이 병목 링크에서 작동하고 경우, 각 연결은 대략 대역폭의 1/n 씩 사용 가능.

- 여러 개의 `병렬 TCP 연결`을 통해 브라우저는 일종의 속임수로 링크 대역폭의 많은 부분을 받게 된다.
  많은 HTTP/1.1 브라우저들은 6개까지 병렬 TCP 연결을 열고 HOL을 막을 뿐만 아니라 더 많은 대역폭을 사용함.

- `HTTP/2` 에서는 `프레이밍(framing)`을 통해 병렬 TCP 연결의 수를 줄이고, TCP 혼잡 제어의 원래 목표를 달성할 수 있도록 하는 것에 초점.
  즉, HOL 블로킹을 피하기 위한 메커니즘이 `HTTP/2 framing`.

##### HTTP/2 프레이밍(framing)

>
> 💡 `HTTP/2 프레이밍(framing)`이란, HTTP 메시지를 `독립된 프레임`들로 쪼개고, 인터리빙(interleaving)*하고, 반대편 사이트에서 재조립하는 것.
>

\* `인터리빙(interleaving)` : 하나의 연결에서 여러 스트림이 전송되는 경우 각 스트림이 번갈아가며 전송하는 것

- `HTTP/2 프로토콜` 의 `framing sub-layer` 에서 이루어짐. HTTP 메세지를 프레임으로 나눌뿐만 아니라 바이너리 인코딩도 동시에 수행함으로써 에러 발생을 감소시키고, 효율적으로 파싱이 가능해짐.

##### 메시지 우선순위화

- 애플리케이션 성능 최적화를 위해 개발자들로 하여금 요청들의 상대적 우선 순위를 조정할 수 있게 하는 것
- 클라이언트가 하나의 특정 서버로 동시에 여러 개의 요청을 할 때, 각 메시지에 1 ~ 256 사이의 가중치를 부여하여 우선순위를 정함 (높은 수치일수록 높은 우선순위).
- 서버는 가장 높은 우선순위의 요청을 위한 프레임을 제일 먼저 보낼 수 있다.
- 클라이언트는 각 의존도에 따라 메시지의 ID를 지정하여 서로 다른 메시지들 간의 의존성을 나타낼 수 있음.

##### 서버 푸싱

- `HTTP/2`는 서버로 하여금 **특정 클라이언트 요청에 대해 여러 개의 응답을 보낼 수 있음**
  처음 요청에 대한 응답 외에도, 서버는 클라이언트의 요청 없이도 추가적인 객체를 클라이언트에게 **푸시** 할 수 있음.

이는 HTML 기반 페이지가 웹 페이지를 완벽하게 구동시킬 필요가 있는 객체들을 가리킬 수 있기에 가능하다.

- 객체에 대한 HTTP 요청을 기다리는 대신 HTML을 분석하여 필요한 객체들을 식별하고, **해당 객체들에 대한 요청이 도착하기도 전에** 해당 객체들을 클라이언트로 전송하여 추가 지연을 없앤다.


##### HTTP/3

트랜스 프로토콜인 QUIC(3장에서 다룬다) 위에서 작동하도록 설계된 새로운 HTTP 프로토콜로서, 완전히 표준화된 상태는 아니다.


### 2.3 인터넷 전자메일

<p align="center">
	<img width="600" alt="전자 메일 시스템" src="https://user-images.githubusercontent.com/76640167/210542924-1107ca75-eee8-45f6-829a-df0d0df81c15.png" />
</p>

>
> Three major components of Electronic mail
> 

- `User agents`
- `Mail servers`
- `SMTP(Simple Mail Transfer Protocol)`

- 사용자 에이전트(User Agent, UA)

- a.k.a. "mail reader"
- 사용자 에이전트는 사용자가 메시지를 읽고, 응답하고, 전달하고, 저장하고, 구성하게 해준다.
- 대표적으로 마이크로 소프트 아웃룩(Outlook), 애플 메일 등이 있다.


- 메일 서버(mail server)

- 전자 메일 인프라스트럭처의 중심이다.
- 각 수신자는 메일 서버에 `메일 박스(mailbox)`를 갖고 있다.
    - 메일 박스는 수신자의 메시지를 유지하고 관리한다.
    - **일반 메시지는 송신자의 사용자 에이전트에서 전달이 시작되고, 송신자의 메일 서버를 거친 후에 수신자의 메일 서버로 전달된다.**  
      거기서 수신자의 메일 박스에 저장된다.
    - 전자메일 박스에 있는 메시지를 보려면 메일 서버는 사용자 계정과 비밀 번호를 이용하여 이용자를 인증하여야 한다.
- 송신자는 메일 서버의 고장에도 대처해야 한다.
    - 만약 메일을 수신자의 메일 서버로 전달할 수 없다면 그 메시지를 `메시지 큐(queue)`에 보관하고 나중에 그 메시지를 전달하기 위해 다시 시도한다.
    - 재시도는 약 30분마다 일어나고, 계속 실패 시에 서버는 그 메시지를 제거하고 송신자에게 통보한다.


- SMTP

> 💡 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜이다.

- SMTP는 메일을 송신자의 메일 서버로부터 수신자의 메일 서버로 전송하는 데에 `TCP의 신뢰적인 데이터 전송 서비스`를 이용한다.
- SMTP는 대부분의 애플리케이션 계층 프로토콜처럼, `클라이언트`와 `서버`를 갖고 있다.
- SMTP의 클라이언트와 서버 모두가 모든 메일 서버에서 수행되고, 상대 메일로 송신할 때는 클라이언트가 되고 수신할 때는 서버가 된다.


#### 2.3.1 SMTP (Simple Message Transfer Protocol)

- \[[RFC 5321](https://datatracker.ietf.org/doc/html/rfc5321)\] 에 정의. `TCP`를 이용하며 일반적으로 `25`번 포트 사용.
- 모든 메일 메시지는 단순한 `7-bit ASCII`로 구성되어야 함.
- 전송 용량이 제한되어 커다란 첨부 파일이나 비디오 파일을 보낼 때 문제 발생.

- 기본 동작 과정

<p align="center">
	<img width="700" alt="메시지 전달 과정" src="https://user-images.githubusercontent.com/76640167/210545342-e280b01b-fff0-4ec7-b921-9bfcddb94999.png" />
</p>

  1. 앨리스는 `전자 메일 사용자 에이전트`를 수행하고, 밥의 전자 메일 주소를 제공하여 메시지를 보내라고 명령한다.
  2. 앨리스의 사용자 에이전트는 메시지를 그녀의 `메일 서버`에게 보내고, 그곳에서 메시지는 `메시지 큐`에 놓인다.
  3. 앨리스의 메일 서버에서 동작하는 SMTP의 클라이언트 측은 메시지 큐에 있는 메시지를 본다. **밥의 메일 서버에서 수행되고 있는 SMTP 서버에게 `TCP 연결`을 설정한다.**
  4. 초기 SMTP 핸드셰이킹 이후에 SMTP 클라이언트는 앨리스의 메시지를 TCP 연결로 보낸다.
  5. 밥의 메일 서버 호스트에서 SMTP의 서버 측은 메시지를 수신한다. 밥의 `메일 서버`는 그 메시지를 밥의 `메일 박스`에 놓는다.
  6. 밥은 편한 시간에 그 메시지를 읽기 위해 `사용자 에이전트`를 시동한다.

- 기본 동작 과정 Detail

  1. 클라이언트 SMTP는 서버의 SMTP의 `25번 포트`로 `TCP 연결`을 설정한다. 서버가 죽어있다면 나중에 시도한다.
  2. 연결이 설정되면, `애플리케이션 계층 핸드셰이킹`을 수행한다. 이때 SMTP 클라이언트는 송신자의 전자메일 주소와 수신자의 전자메일 주소를 제공한다.
  3. 이후 클라이언트는 메시지를 보낸다. (TCP의 신뢰적인 데이터 전송 서비스에 의존)
  4. **보낼 다른 메시지가 있다면 같은 TCP 연결 상에서 반복하며**, 그렇지 않으면 TCP를 닫는다. (`지속 연결(persistent connection)`)

---

- `SMTP` **중간 메일 서버를 이용하지 않음**. 메세지 전송에 실패할 경우 **송신자의 메일 서버에 남아있음.**


##### SMTP 클라이언트(C)와 SMTP 서버(S) 사이의 메시지 전달 과정 예시

```
S:  220 hamburger.edu
C:  HELO crepes.fr
S:  250 Hello crepes.fr, pleased to meet you
C:  MAIL FROM: <alice@crepes.fr>
S:  250 alice@crepes.fr ... Sender ok
C:  RCPT TO: <bob@hamburger.edu>
S:  250 bob@hamburger.edu ... Recipient ok
C:  DATA
S:  354 Enter mail, end with ”.” on a line by itself
C:  Do you like ketchup?
C:  How about pickles?
C:  .
S:  250 Message accepted for delivery
C:  QUIT
S:  221 hamburger.edu closing connection
```

<p align="center">
	<img width="830" alt="메시지 전달 과정 예시" src="https://user-images.githubusercontent.com/86337233/232236656-a28366f7-e268-4cd4-a525-86b39c658069.png" />
</p>

- 클라이언트는 5개의 명령 (`HELO`, `MAIL FROM`, `RCPT TO`, `DATA`, `QUIT`)을 내림
- 하나의 점(`.`)으로 된 라인은 **서버에서 메시지의 끝을 의미**
- 서버는 각 명령에 응답하며, 각 응답에는 응답 코드와 영문 설명 표시

- `SMTP`는 **지속 연결(persistent connection) 사용**. 즉, 같은 수신 메일 서버로 보내는 여러 메시지를 갖고 있다면, **같은 TCP 연결을 통해 모든 메시지 전달 가능.**

- `telnet 명령어`를 사용하여 원격 메일 서버와 위와 같은 대화 가능


#### 2.3.2 메일 메시지 포맷

<p align="center">
	<img width="600" alt="메시지 포맷" src="https://user-images.githubusercontent.com/86337233/232237089-44b78dca-e43b-458c-9de0-f2756195c8a1.png" />
</p>

- 전자메일은 `CRLF`로 구분된 `헤더(header)`, `메시지 몸체(body)`로 구성.
- `헤더`는 \[[RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)\]에 정의.
- 모든 `헤더`는 `From:`, `To:` 두가지 헤더 라인을 반드시 포함. (나머지는 선택사항)
- 일반 메시지 헤더 예시

```SMTP
From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.

Message
```


#### 2.3.3 메일 접속 프로토콜(Mail access protocols)

<p align="center">
	<img width="770" alt="전자메일 프로토콜" src="https://user-images.githubusercontent.com/76640167/210550668-901b362b-a929-4d44-abe8-da7bf21ca857.png" />
</p>

- `메일 서버` : 메일 박스 관리. `SMTP 클라이언트`, `SMTP 서버` 역할 모두 수행. 보통 사용자들과 공유함.
-  메일 서버가 로컬 호스트에 있다면, 호스트는 언제든 도착할 수 있는 전자 메일을 수신하기 위해 항상 켜져 있어야 하고 인터넷에 연결되어 있어야 한다. 이는 대부분의 인터넷 사용자에게는 비현실적이다.
- 일반 사용자는 로컬 호스트에서 사용자 에이전트를 수행하고 **늘 켜져 있는 공유 메일 서버에 저장된 메일박스에 접근한다.**

- 송신자의 사용자 에이전트는 수신자의 메일 서버와 직접 대화하지 않음.
  1. `송신자의 사용자 에이전트`는 `송신자의 메일 서버`로 전자메일 메시지를 `SMTP` 또는 `HTTP`를 이용하여 전송
  2. `송신자의 메일 서버`는 `SMTP`를 이용하여 `수신자의 메일 서버`로 전자메일 메시지를 중계

- `송신자의 사용자 에이전트`는 `송신자의 메일 서버`를 거치지 않고서는 `수신자의 메일 서버`에 도달할 수 없음.
- `송신자`는 전자메일을 자신의 메일 서버에 먼저 저장한 후 `수신자`가 메일을 전달받을 때까지 매 30분마다 `수신자 메일서버`로 전송 시도.

- `수신자`는 자신의 ISP 내부의 메일 서버에 메시지를 어떻게 얻을 수 있는가?
  - `SMTP`는 `push` 프로토콜. 따라서 메시지를 얻는 `pull` 동작에 필요한 다른 프로토콜 필요.
  - 두 가지 대표적인 방법
    - `HTTP` : 웹 기반 전자메일이나 스마트폰 앱에서 사용. 메일 서버는 `SMTP 인터페이스`, `HTTP 인터페이스` 둘 다 필요.
    - `IMAP`\[[RFC 3501](https://datatracker.ietf.org/doc/html/rfc3501)\] : 인터넷 메일 접근 프로토콜
